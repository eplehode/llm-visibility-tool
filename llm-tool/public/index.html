<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Visibility Diagnosis Tool - Multi-Page Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.95;
        }

        .input-section {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .input-mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            background: #f5f5f5;
            padding: 5px;
            border-radius: 10px;
        }

        .mode-btn {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
        }

        .mode-btn.active {
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            color: #667eea;
            font-weight: 600;
        }

        .single-input {
            display: block;
        }

        .multi-input {
            display: none;
        }

        .multi-input.active {
            display: block;
        }

        .single-input.active {
            display: block;
        }

        .input-group {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }

        input[type="text"], input[type="url"] {
            flex: 1;
            padding: 15px 20px;
            font-size: 1.1rem;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            transition: all 0.3s;
        }

        input[type="text"]:focus, input[type="url"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
        }

        .page-inputs {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .page-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 12px;
        }

        .page-label {
            min-width: 140px;
            font-weight: 500;
            color: #555;
        }

        .page-input-group input {
            flex: 1;
            padding: 10px 15px;
            font-size: 0.95rem;
        }

        .optional-tag {
            color: #999;
            font-size: 0.85rem;
            font-weight: normal;
        }

        .analyze-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102,126,234,0.3);
        }

        .analyze-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .help-text {
            color: #666;
            font-size: 0.9rem;
            margin-top: 10px;
            padding: 10px;
            background: #f0f0ff;
            border-radius: 8px;
        }

        .results-section {
            display: none;
        }

        .results-section.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .results-tabs {
            background: white;
            border-radius: 20px 20px 0 0;
            padding: 5px;
            margin-bottom: 0;
            display: flex;
            gap: 5px;
            overflow-x: auto;
        }

        .tab-btn {
            padding: 12px 20px;
            background: transparent;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.95rem;
            white-space: nowrap;
            transition: all 0.3s;
            color: #666;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
        }

        .tab-content {
            background: white;
            padding: 30px;
            border-radius: 0 0 20px 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .comparison-table th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        .comparison-table tr:hover {
            background: #f5f5f5;
        }

        .score-cell {
            font-weight: bold;
            text-align: center;
        }

        .overall-score {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .score-circle {
            width: 200px;
            height: 200px;
            margin: 0 auto 20px;
            position: relative;
        }

        .score-circle svg {
            transform: rotate(-90deg);
        }

        .score-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #333;
        }

        .score-label {
            font-size: 1.3rem;
            color: #666;
            margin-bottom: 10px;
        }

        .score-status {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 10px;
        }

        .factors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .factor-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            transition: all 0.3s;
        }

        .factor-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.12);
        }

        .factor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .factor-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
        }

        .factor-score {
            font-size: 1.3rem;
            font-weight: bold;
            padding: 5px 15px;
            border-radius: 20px;
            background: #f5f5f5;
        }

        .factor-details {
            color: #666;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .factor-items {
            list-style: none;
        }

        .factor-items li {
            padding: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .check-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }

        .check-icon.pass {
            background: #4caf50;
        }

        .check-icon.fail {
            background: #f44336;
        }

        .check-icon.partial {
            background: #ff9800;
        }

        .recommendations {
            background: white;
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .recommendations h2 {
            color: #333;
            margin-bottom: 25px;
            font-size: 1.8rem;
        }

        .factor-section {
            margin-bottom: 40px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 4px solid #667eea;
        }

        .factor-section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .factor-explanation {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 0.95rem;
            color: #555;
            line-height: 1.6;
        }

        .recommendation-item {
            background: white;
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 10px;
            border-left: 3px solid #764ba2;
        }

        .recommendation-priority {
            display: inline-block;
            padding: 5px 15px;
            background: #667eea;
            color: white;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .priority-high {
            background: #f44336;
        }

        .priority-medium {
            background: #ff9800;
        }

        .priority-low {
            background: #4caf50;
        }

        .recommendation-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .recommendation-steps {
            margin-top: 15px;
            padding-left: 20px;
        }

        .recommendation-steps li {
            margin-bottom: 8px;
            color: #666;
            line-height: 1.6;
        }

        .debug-info {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.85rem;
            margin-top: 10px;
            font-family: monospace;
        }

        .loading {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 20px;
            margin-bottom: 30px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #c62828;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #f5f5f5;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 15px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }

        .current-page-indicator {
            color: #667eea;
            font-weight: 600;
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 LLM Visibility Diagnosis Tool</h1>
            <p>Analyze how well AI assistants can discover, understand, and cite your website</p>
            <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 5px;">8 Real Factors • Multi-Page Analysis • Complete Recommendations</p>
        </div>

        <div class="input-section">
            <div class="input-mode-toggle">
                <button class="mode-btn active" onclick="toggleMode('single')">Single Page Analysis</button>
                <button class="mode-btn" onclick="toggleMode('multi')">Multi-Page Analysis</button>
            </div>

            <!-- Single Page Input -->
            <div class="single-input active">
                <div class="input-group">
                    <input type="text" id="domainInput" placeholder="Enter domain or URL (e.g., example.com or example.com/blog/article)" />
                </div>
                <button class="analyze-btn" onclick="analyzeSingle()">Analyze Page</button>
            </div>

            <!-- Multi Page Input -->
            <div class="multi-input">
                <div class="input-group">
                    <input type="text" id="mainDomainInput" placeholder="Enter main domain (e.g., example.com)" />
                </div>
                
                <div class="page-inputs">
                    <h3 style="margin-bottom: 15px; color: #333;">Add specific pages to analyze (optional):</h3>
                    
                    <div class="page-input-group">
                        <label class="page-label">Homepage:</label>
                        <input type="url" id="homepageUrl" placeholder="Auto-filled from domain">
                    </div>
                    
                    <div class="page-input-group">
                        <label class="page-label">Blog/Article:</label>
                        <input type="url" id="blogUrl" placeholder="e.g., example.com/blog/best-practices">
                    </div>
                    
                    <div class="page-input-group">
                        <label class="page-label">About Us:</label>
                        <input type="url" id="aboutUrl" placeholder="e.g., example.com/about">
                    </div>
                    
                    <div class="page-input-group">
                        <label class="page-label">Product/Service:</label>
                        <input type="url" id="productUrl" placeholder="e.g., example.com/products/main-product">
                    </div>
                    
                    <div class="page-input-group">
                        <label class="page-label">Contact:</label>
                        <input type="url" id="contactUrl" placeholder="e.g., example.com/contact">
                    </div>
                    
                    <div class="page-input-group">
                        <label class="page-label">FAQ:</label>
                        <input type="url" id="faqUrl" placeholder="e.g., example.com/faq">
                    </div>
                    
                    <div class="page-input-group">
                        <label class="page-label">Custom Page:</label>
                        <input type="url" id="customUrl" placeholder="Any other important page">
                    </div>
                </div>
                
                <button class="analyze-btn" onclick="analyzeMultiple()">Analyze All Pages</button>
                
                <div class="help-text">
                    💡 <strong>Tip:</strong> Leave fields empty to skip them. The tool will analyze each provided URL and show individual + aggregate results.
                </div>
            </div>
        </div>

        <div id="loadingSection" class="loading" style="display: none;">
            <div class="spinner"></div>
            <p id="loadingMessage">Analyzing website visibility for AI assistants...</p>
            <div class="current-page-indicator" id="currentPageIndicator"></div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%">0%</div>
            </div>
        </div>

        <div id="errorSection" style="display: none;">
            <div class="error-message" id="errorMessage"></div>
        </div>

        <div id="resultsSection" class="results-section">
            <!-- Tabs will be dynamically added here -->
        </div>
    </div>

    <script>
        // ===== CONFIGURATION - YOUR VERCEL URL IS HERE! =====
        const PROXY_BASE_URL = 'https://llm-visibility-tool-chi.vercel.app/api/analyze';
        
        // Configuration for bot checking
        const AI_BOTS = ['GPTBot', 'OAI-SearchBot', 'ClaudeBot', 'PerplexityBot', 'ChatGPT-User', 'CCBot', 'Amazonbot', 'Applebot'];
        
        let analysisResults = {};
        let currentMode = 'single';
        let multiPageResults = {};

        // Auto-fill homepage when domain is entered
        document.getElementById('mainDomainInput').addEventListener('input', function(e) {
            const domain = e.target.value.trim().replace(/^https?:\/\//, '').replace(/\/$/, '');
            if (domain) {
                document.getElementById('homepageUrl').placeholder = `https://${domain}`;
            }
        });

        function toggleMode(mode) {
            currentMode = mode;
            
            // Update buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Show/hide inputs
            if (mode === 'single') {
                document.querySelector('.single-input').style.display = 'block';
                document.querySelector('.multi-input').style.display = 'none';
            } else {
                document.querySelector('.single-input').style.display = 'none';
                document.querySelector('.multi-input').style.display = 'block';
            }
        }

        async function analyzeSingle() {
            const domainInput = document.getElementById('domainInput');
            const url = domainInput.value.trim();
            
            if (!url) {
                showError('Please enter a valid domain or URL');
                return;
            }

            // Reset and show loading
            document.getElementById('resultsSection').classList.remove('active');
            document.getElementById('resultsSection').innerHTML = '';
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('loadingSection').style.display = 'block';
            document.getElementById('loadingMessage').textContent = 'Analyzing page...';
            document.getElementById('currentPageIndicator').textContent = '';
            
            try {
                const cleanUrl = url.replace(/^https?:\/\//, '').replace(/\/$/, '');
                await performAnalysis(cleanUrl, 'Single Page');
                displaySingleResults();
            } catch (error) {
                showError(`Analysis failed: ${error.message}`);
            } finally {
                document.getElementById('loadingSection').style.display = 'none';
            }
        }

        async function analyzeMultiple() {
            const mainDomain = document.getElementById('mainDomainInput').value.trim();
            
            if (!mainDomain) {
                showError('Please enter the main domain');
                return;
            }

            // Collect all URLs to analyze
            const pages = [
                { 
                    name: 'Homepage', 
                    url: document.getElementById('homepageUrl').value || `https://${mainDomain.replace(/^https?:\/\//, '')}`,
                    type: 'homepage'
                },
                { 
                    name: 'Blog/Article', 
                    url: document.getElementById('blogUrl').value,
                    type: 'blog'
                },
                { 
                    name: 'About Us', 
                    url: document.getElementById('aboutUrl').value,
                    type: 'about'
                },
                { 
                    name: 'Product/Service', 
                    url: document.getElementById('productUrl').value,
                    type: 'product'
                },
                { 
                    name: 'Contact', 
                    url: document.getElementById('contactUrl').value,
                    type: 'contact'
                },
                { 
                    name: 'FAQ', 
                    url: document.getElementById('faqUrl').value,
                    type: 'faq'
                },
                { 
                    name: 'Custom Page', 
                    url: document.getElementById('customUrl').value,
                    type: 'custom'
                }
            ].filter(page => page.url); // Only include pages with URLs

            if (pages.length === 0) {
                showError('Please enter at least one URL to analyze');
                return;
            }

            // Reset results
            multiPageResults = {};
            document.getElementById('resultsSection').classList.remove('active');
            document.getElementById('resultsSection').innerHTML = '';
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('loadingSection').style.display = 'block';
            
            // Analyze each page
            for (let i = 0; i < pages.length; i++) {
                const page = pages[i];
                document.getElementById('loadingMessage').textContent = `Analyzing ${page.name}...`;
                document.getElementById('currentPageIndicator').textContent = `Page ${i + 1} of ${pages.length}`;
                
                try {
                    const cleanUrl = page.url.replace(/^https?:\/\//, '').replace(/\/$/, '');
                    await performAnalysis(cleanUrl, page.name);
                    multiPageResults[page.type] = {
                        name: page.name,
                        url: page.url,
                        results: {...analysisResults}
                    };
                } catch (error) {
                    console.error(`Failed to analyze ${page.name}:`, error);
                    multiPageResults[page.type] = {
                        name: page.name,
                        url: page.url,
                        error: error.message
                    };
                }
                
                // Update overall progress
                const overallProgress = ((i + 1) / pages.length) * 100;
                updateProgress(overallProgress, `Completed ${i + 1} of ${pages.length} pages`);
            }
            
            document.getElementById('loadingSection').style.display = 'none';
            displayMultiPageResults();
        }

        async function performAnalysis(url, pageName = '') {
            analysisResults = {
                url: url,
                pageName: pageName,
                factors: {},
                totalScore: 0
            };

            // Determine if it's a full URL or just domain
            const baseUrl = url.startsWith('http') ? url : `https://${url}`;
            
            // Update progress for single page analysis
            if (!pageName || currentMode === 'single') {
                updateProgress(12, 'Checking bot accessibility...');
            }
            analysisResults.factors.botAccessibility = await checkBotAccessibility(baseUrl);
            
            if (!pageName || currentMode === 'single') {
                updateProgress(24, 'Analyzing content structure...');
            }
            analysisResults.factors.parsability = await checkParsability(baseUrl);
            
            if (!pageName || currentMode === 'single') {
                updateProgress(36, 'Evaluating citation friendliness...');
            }
            analysisResults.factors.citationFriendliness = await checkCitationFriendliness(baseUrl);
            
            if (!pageName || currentMode === 'single') {
                updateProgress(48, 'Assessing authority signals...');
            }
            analysisResults.factors.authority = await checkAuthority(baseUrl);
            
            if (!pageName || currentMode === 'single') {
                updateProgress(60, 'Checking content freshness...');
            }
            analysisResults.factors.freshness = await checkFreshness(baseUrl);
            
            if (!pageName || currentMode === 'single') {
                updateProgress(72, 'Analyzing technical signals...');
            }
            analysisResults.factors.technical = await checkTechnical(baseUrl);
            
            if (!pageName || currentMode === 'single') {
                updateProgress(84, 'Reviewing content formats...');
            }
            analysisResults.factors.contentFormat = await checkContentFormat(baseUrl);
            
            if (!pageName || currentMode === 'single') {
                updateProgress(96, 'Checking licensing readiness...');
            }
            analysisResults.factors.licensing = await checkLicensing(baseUrl);
            
            if (!pageName || currentMode === 'single') {
                updateProgress(100, 'Generating report...');
            }
            
            // Calculate total score
            calculateTotalScore();
        }

        function displaySingleResults() {
            const resultsSection = document.getElementById('resultsSection');
            
            const html = `
                <div class="overall-score">
                    <div class="score-circle">
                        <svg width="200" height="200">
                            <circle cx="100" cy="100" r="90" stroke="#e0e0e0" stroke-width="20" fill="none"/>
                            <circle id="scoreCircle" cx="100" cy="100" r="90" stroke="url(#gradient)" stroke-width="20" fill="none" 
                                    stroke-dasharray="565" stroke-dashoffset="565" stroke-linecap="round"/>
                            <defs>
                                <linearGradient id="gradient">
                                    <stop offset="0%" stop-color="#667eea"/>
                                    <stop offset="100%" stop-color="#764ba2"/>
                                </linearGradient>
                            </defs>
                        </svg>
                        <div class="score-number" id="totalScore">0</div>
                    </div>
                    <div class="score-label">LLM Visibility Score (out of 80)</div>
                    <div class="score-status" id="scoreStatus">Calculating...</div>
                </div>

                <div class="factors-grid" id="factorsGrid"></div>
                <div class="recommendations" id="recommendations"></div>
            `;
            
            resultsSection.innerHTML = html;
            resultsSection.classList.add('active');
            
            // Animate score
            animateScore(analysisResults.totalScore);
            
            // Display factors
            displayFactors();
            
            // Generate recommendations
            generateAllRecommendations();
        }

        function displayMultiPageResults() {
            const resultsSection = document.getElementById('resultsSection');
            
            // Create tabs
            let tabsHtml = '<div class="results-tabs">';
            tabsHtml += '<button class="tab-btn active" onclick="showTab(\'overview\')">Overview</button>';
            
            Object.keys(multiPageResults).forEach(type => {
                const page = multiPageResults[type];
                if (!page.error) {
                    tabsHtml += `<button class="tab-btn" onclick="showTab('${type}')">${page.name}</button>`;
                }
            });
            
            tabsHtml += '</div>';
            
            // Create tab contents
            let contentHtml = '';
            
            // Overview tab
            contentHtml += '<div id="overview-tab" class="tab-content active">';
            contentHtml += generateOverviewContent();
            contentHtml += '</div>';
            
            // Individual page tabs
            Object.keys(multiPageResults).forEach(type => {
                const page = multiPageResults[type];
                if (!page.error) {
                    contentHtml += `<div id="${type}-tab" class="tab-content">`;
                    contentHtml += generatePageContent(page);
                    contentHtml += '</div>';
                }
            });
            
            resultsSection.innerHTML = tabsHtml + contentHtml;
            resultsSection.classList.add('active');
        }

        function generateOverviewContent() {
            let html = '<h2>📊 Multi-Page Analysis Overview</h2>';
            
            // Calculate average scores
            const factorAverages = {};
            let pageCount = 0;
            let totalAverage = 0;
            
            Object.keys(multiPageResults).forEach(type => {
                const page = multiPageResults[type];
                if (!page.error && page.results) {
                    pageCount++;
                    totalAverage += page.results.totalScore;
                    
                    Object.keys(page.results.factors).forEach(factor => {
                        if (!factorAverages[factor]) {
                            factorAverages[factor] = { total: 0, count: 0, scores: [] };
                        }
                        factorAverages[factor].total += page.results.factors[factor].value;
                        factorAverages[factor].count++;
                        factorAverages[factor].scores.push({
                            page: page.name,
                            score: page.results.factors[factor].value
                        });
                    });
                }
            });
            
            if (pageCount > 0) {
                totalAverage = Math.round(totalAverage / pageCount);
            }
            
            // Overall average score
            html += `
                <div class="overall-score" style="margin-bottom: 30px;">
                    <h3>Average LLM Visibility Score: ${totalAverage}/80</h3>
                    <p style="color: #666;">Based on ${pageCount} pages analyzed</p>
                </div>
            `;
            
            // Comparison table
            html += `
                <h3>Page Comparison</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Page</th>
                            <th>Total Score</th>
                            <th>Bot Access</th>
                            <th>Structure</th>
                            <th>Citations</th>
                            <th>Authority</th>
                            <th>Freshness</th>
                            <th>Technical</th>
                            <th>Format</th>
                            <th>Licensing</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            Object.keys(multiPageResults).forEach(type => {
                const page = multiPageResults[type];
                if (!page.error && page.results) {
                    const factors = page.results.factors;
                    html += `
                        <tr>
                            <td><strong>${page.name}</strong></td>
                            <td class="score-cell" style="color: ${getScoreColor(page.results.totalScore, 80)}">${page.results.totalScore}/80</td>
                            <td class="score-cell" style="color: ${getScoreColor(factors.botAccessibility.value, 10)}">${factors.botAccessibility.value}/10</td>
                            <td class="score-cell" style="color: ${getScoreColor(factors.parsability.value, 10)}">${factors.parsability.value}/10</td>
                            <td class="score-cell" style="color: ${getScoreColor(factors.citationFriendliness.value, 10)}">${factors.citationFriendliness.value}/10</td>
                            <td class="score-cell" style="color: ${getScoreColor(factors.authority.value, 10)}">${factors.authority.value}/10</td>
                            <td class="score-cell" style="color: ${getScoreColor(factors.freshness.value, 10)}">${factors.freshness.value}/10</td>
                            <td class="score-cell" style="color: ${getScoreColor(factors.technical.value, 10)}">${factors.technical.value}/10</td>
                            <td class="score-cell" style="color: ${getScoreColor(factors.contentFormat.value, 10)}">${factors.contentFormat.value}/10</td>
                            <td class="score-cell" style="color: ${getScoreColor(factors.licensing.value, 10)}">${factors.licensing.value}/10</td>
                        </tr>
                    `;
                }
            });
            
            // Add averages row
            html += '<tr style="background: #f0f0ff; font-weight: bold;">';
            html += '<td>Average</td>';
            html += `<td class="score-cell">${totalAverage}/80</td>`;
            
            ['botAccessibility', 'parsability', 'citationFriendliness', 'authority', 'freshness', 'technical', 'contentFormat', 'licensing'].forEach(factor => {
                if (factorAverages[factor]) {
                    const avg = Math.round(factorAverages[factor].total / factorAverages[factor].count);
                    html += `<td class="score-cell">${avg}/10</td>`;
                } else {
                    html += '<td>-</td>';
                }
            });
            
            html += '</tr></tbody></table>';
            
            // Key insights
            html += '<div style="margin-top: 30px;"><h3>🔍 Key Insights</h3>';
            
            // Best performing page
            let bestPage = null;
            let bestScore = 0;
            Object.keys(multiPageResults).forEach(type => {
                const page = multiPageResults[type];
                if (!page.error && page.results && page.results.totalScore > bestScore) {
                    bestScore = page.results.totalScore;
                    bestPage = page.name;
                }
            });
            
            // Worst performing page
            let worstPage = null;
            let worstScore = 100;
            Object.keys(multiPageResults).forEach(type => {
                const page = multiPageResults[type];
                if (!page.error && page.results && page.results.totalScore < worstScore) {
                    worstScore = page.results.totalScore;
                    worstPage = page.name;
                }
            });
            
            html += `
                <ul style="line-height: 2;">
                    <li>📈 <strong>Best performing page:</strong> ${bestPage} (${bestScore}/80)</li>
                    <li>📉 <strong>Needs most improvement:</strong> ${worstPage} (${worstScore}/80)</li>
            `;
            
            // Find weakest factors across all pages
            let weakestFactor = null;
            let weakestAvg = 10;
            Object.keys(factorAverages).forEach(factor => {
                const avg = factorAverages[factor].total / factorAverages[factor].count;
                if (avg < weakestAvg) {
                    weakestAvg = avg;
                    weakestFactor = factor;
                }
            });
            
            const factorNames = {
                botAccessibility: 'Bot Accessibility',
                parsability: 'Parsability & Structure',
                citationFriendliness: 'Citation Friendliness',
                authority: 'Authority & Trust',
                freshness: 'Freshness & Feeds',
                technical: 'Technical Signals',
                contentFormat: 'Content Format',
                licensing: 'Licensing Readiness'
            };
            
            html += `
                    <li>⚠️ <strong>Weakest factor overall:</strong> ${factorNames[weakestFactor]} (avg: ${Math.round(weakestAvg)}/10)</li>
                    <li>💡 <strong>Recommendation:</strong> Focus on improving ${factorNames[weakestFactor]} across all pages for maximum impact</li>
                </ul>
            </div>`;
            
            return html;
        }

        function generatePageContent(page) {
            // Temporarily set global analysisResults to this page's results
            analysisResults = page.results;
            
            let html = `
                <h2>Analysis: ${page.name}</h2>
                <p style="color: #666; margin-bottom: 20px;">URL: ${page.url}</p>
                
                <div class="overall-score">
                    <div class="score-circle">
                        <svg width="200" height="200">
                            <circle cx="100" cy="100" r="90" stroke="#e0e0e0" stroke-width="20" fill="none"/>
                            <circle class="page-score-circle" cx="100" cy="100" r="90" stroke="url(#gradient-${page.name.replace(/\s+/g, '-')})" 
                                    stroke-width="20" fill="none" stroke-dasharray="565" stroke-dashoffset="${565 - (page.results.totalScore / 80) * 565}" stroke-linecap="round"/>
                            <defs>
                                <linearGradient id="gradient-${page.name.replace(/\s+/g, '-')}">
                                    <stop offset="0%" stop-color="#667eea"/>
                                    <stop offset="100%" stop-color="#764ba2"/>
                                </linearGradient>
                            </defs>
                        </svg>
                        <div class="score-number">${page.results.totalScore}</div>
                    </div>
                    <div class="score-label">LLM Visibility Score (out of 80)</div>
                    <div class="score-status" style="color: ${getStatusColor(page.results.totalScore)}">${getStatus(page.results.totalScore)}</div>
                </div>
                
                <div class="factors-grid" id="factors-${page.name.replace(/\s+/g, '-')}"></div>
                <div class="recommendations" id="recommendations-${page.name.replace(/\s+/g, '-')}"></div>
            `;
            
            // Generate factor cards and recommendations for this page
            setTimeout(() => {
                if (document.getElementById(`factors-${page.name.replace(/\s+/g, '-')}`)) {
                    displayFactorsForPage(page.results, `factors-${page.name.replace(/\s+/g, '-')}`);
                    generateRecommendationsForPage(page.results, `recommendations-${page.name.replace(/\s+/g, '-')}`);
                }
            }, 100);
            
            return html;
        }

        function displayFactorsForPage(results, elementId) {
            const factorsGrid = document.getElementById(elementId);
            if (!factorsGrid) return;
            
            factorsGrid.innerHTML = '';
            
            const factorNames = {
                botAccessibility: 'Bot Accessibility',
                parsability: 'Parsability & Structure',
                citationFriendliness: 'Citation Friendliness',
                authority: 'Authority & Trust',
                freshness: 'Freshness & Feeds',
                technical: 'Technical Signals',
                contentFormat: 'Content Format',
                licensing: 'Licensing Readiness'
            };
            
            for (const [key, factor] of Object.entries(results.factors)) {
                const card = createFactorCard(factorNames[key], factor);
                factorsGrid.appendChild(card);
            }
        }

        function generateRecommendationsForPage(results, elementId) {
            const recommendationsEl = document.getElementById(elementId);
            if (!recommendationsEl) return;
            
            // Use the existing generateAllRecommendations logic but target specific element
            analysisResults = results; // Temporarily set for recommendation generation
            const html = generateRecommendationsHTML();
            recommendationsEl.innerHTML = html;
        }

        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            // Update button state
            event.target.classList.add('active');
        }

        function getScoreColor(score, max) {
            const percentage = (score / max) * 100;
            if (percentage >= 70) return '#4caf50';
            if (percentage >= 40) return '#ff9800';
            return '#f44336';
        }

        function getStatus(score) {
            if (score >= 70) return 'Excellent LLM Visibility';
            if (score >= 50) return 'Good LLM Visibility';
            if (score >= 35) return 'Moderate LLM Visibility';
            return 'Needs Improvement';
        }

        function getStatusColor(score) {
            if (score >= 50) return '#4caf50';
            if (score >= 35) return '#ff9800';
            return '#f44336';
        }

        async function fetchWithCORS(url, type = 'html') {
            try {
                // Extract domain from URL if it's a full URL
                let domain = url.replace(/^https?:\/\//, '').replace(/\/$/, '');
                
                // For specific resources, extract just the domain
                if (url.includes('/robots.txt')) {
                    domain = new URL(url).hostname;
                    type = 'robots';
                } else if (url.includes('/sitemap.xml')) {
                    domain = new URL(url).hostname;
                    type = 'sitemap';
                } else if (url.includes('/llms.txt')) {
                    domain = new URL(url).hostname;
                    type = 'llms';
                }
                
                // Call your Vercel proxy
                const proxyUrl = `${PROXY_BASE_URL}?url=${encodeURIComponent(domain)}&type=${type}`;
                console.log('Fetching via proxy:', proxyUrl);
                
                const response = await fetch(proxyUrl);
                const data = await response.json();
                
                if (data.success) {
                    return data.content;
                } else {
                    console.error('Proxy error:', data.error);
                    return null;
                }
            } catch (error) {
                console.error('Fetch error:', error);
                return null;
            }
        }

        // [Include all the checking functions from the previous version - they remain the same]
        // checkBotAccessibility, checkParsability, checkCitationFriendliness, etc.
        
        async function checkBotAccessibility(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                // For URLs with paths, extract just the domain for robots.txt
                const urlObj = new URL(baseUrl);
                const robotsUrl = `${urlObj.protocol}//${urlObj.hostname}/robots.txt`;
                const robotsContent = await fetchWithCORS(robotsUrl);
                
                if (robotsContent) {
                    score.details.push('robots.txt found');
                    score.checks.push({ name: 'robots.txt exists', status: 'pass' });
                    score.value += 3;
                    
                    // Check for AI bot allowances
                    const allowedBots = AI_BOTS.filter(bot => {
                        const disallowPattern = new RegExp(`User-agent:\\s*${bot}\\s*\\nDisallow:\\s*/`, 'i');
                        const allowPattern = new RegExp(`User-agent:\\s*${bot}\\s*\\nAllow:\\s*/`, 'i');
                        const isDisallowed = disallowPattern.test(robotsContent);
                        const isAllowed = allowPattern.test(robotsContent);
                        
                        const wildcardAllow = robotsContent.includes('User-agent: *') && 
                                            !robotsContent.includes('Disallow: /');
                        
                        return isAllowed || (!isDisallowed && wildcardAllow);
                    });
                    
                    score.debug.push(`Found ${allowedBots.length} allowed bots: ${allowedBots.join(', ')}`);
                    
                    if (allowedBots.length > 0) {
                        score.value += Math.min(4, allowedBots.length);
                        score.details.push(`${allowedBots.length} AI bots allowed`);
                        score.checks.push({ name: 'AI bots allowed', status: allowedBots.length > 2 ? 'pass' : 'partial' });
                    } else {
                        score.checks.push({ name: 'AI bots allowed', status: 'fail' });
                    }
                    
                    if (robotsContent.toLowerCase().includes('llms.txt')) {
                        score.value += 2;
                        score.details.push('llms.txt reference found');
                        score.checks.push({ name: 'llms.txt configured', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'llms.txt configured', status: 'fail' });
                    }
                } else {
                    score.checks.push({ name: 'robots.txt exists', status: 'fail' });
                    score.checks.push({ name: 'AI bots allowed', status: 'fail' });
                    score.checks.push({ name: 'llms.txt configured', status: 'fail' });
                }
                
                // Check for llms.txt directly
                try {
                    const llmsUrl = `${urlObj.protocol}//${urlObj.hostname}/llms.txt`;
                    const llmsContent = await fetchWithCORS(llmsUrl);
                    if (llmsContent) {
                        score.value += 1;
                        score.details.push('llms.txt file exists');
                    }
                } catch (e) {
                    // llms.txt not found
                }
                
            } catch (error) {
                score.details.push('Unable to check bot accessibility');
            }
            
            return score;
        }

        async function checkParsability(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for proper heading structure
                    const h1Count = doc.querySelectorAll('h1').length;
                    const h2Count = doc.querySelectorAll('h2').length;
                    const h3Count = doc.querySelectorAll('h3').length;
                    
                    score.debug.push(`Found: ${h1Count} H1s, ${h2Count} H2s, ${h3Count} H3s`);
                    
                    if (h1Count > 0) {
                        score.value += 2;
                        score.details.push(`${h1Count} H1 tag(s) found`);
                        score.checks.push({ name: 'H1 headings present', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'H1 headings present', status: 'fail' });
                    }
                    
                    if (h2Count > 0 && h3Count > 0) {
                        score.value += 3;
                        score.details.push('Hierarchical heading structure');
                        score.checks.push({ name: 'H2-H3 hierarchy', status: 'pass' });
                    } else if (h2Count > 0) {
                        score.value += 1;
                        score.checks.push({ name: 'H2-H3 hierarchy', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'H2-H3 hierarchy', status: 'fail' });
                    }
                    
                    // Check for schema markup (multiple ways)
                    const schemaScripts = doc.querySelectorAll('script[type="application/ld+json"]');
                    const microdataItems = doc.querySelectorAll('[itemscope]');
                    const rdfa = doc.querySelectorAll('[typeof]');
                    
                    if (schemaScripts.length > 0 || microdataItems.length > 0 || rdfa.length > 0) {
                        score.value += 3;
                        score.details.push('Schema/structured markup found');
                        score.checks.push({ name: 'Schema.org markup', status: 'pass' });
                        score.debug.push(`Schema: ${schemaScripts.length} JSON-LD, ${microdataItems.length} microdata, ${rdfa.length} RDFa`);
                    } else {
                        score.checks.push({ name: 'Schema.org markup', status: 'fail' });
                    }
                    
                    // Check for semantic HTML
                    const semanticElements = {
                        article: doc.querySelectorAll('article').length,
                        main: doc.querySelectorAll('main').length,
                        nav: doc.querySelectorAll('nav').length,
                        section: doc.querySelectorAll('section').length,
                        aside: doc.querySelectorAll('aside').length,
                        header: doc.querySelectorAll('header').length,
                        footer: doc.querySelectorAll('footer').length
                    };
                    
                    const totalSemantic = Object.values(semanticElements).reduce((a, b) => a + b, 0);
                    
                    if (totalSemantic >= 3) {
                        score.value += 2;
                        score.details.push('Good semantic HTML structure');
                        score.checks.push({ name: 'Semantic HTML tags', status: 'pass' });
                    } else if (totalSemantic >= 1) {
                        score.value += 1;
                        score.checks.push({ name: 'Semantic HTML tags', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Semantic HTML tags', status: 'fail' });
                    }
                    
                    score.debug.push(`Semantic elements: ${JSON.stringify(semanticElements)}`);
                }
            } catch (error) {
                score.details.push('Unable to analyze page structure');
            }
            
            return score;
        }

        async function checkCitationFriendliness(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Enhanced author detection
                    const authorChecks = [
                        doc.querySelector('meta[name="author"]'),
                        doc.querySelector('meta[property="article:author"]'),
                        doc.querySelector('meta[name="dc.creator"]'),
                        doc.querySelector('meta[property="og:author"]'),
                        doc.querySelector('link[rel="author"]'),
                        doc.querySelector('[rel="author"]'),
                        doc.querySelector('.author, .by-author, .byline, .by, .written-by'),
                        doc.querySelector('[itemprop="author"]'),
                        doc.querySelector('address'),
                        htmlContent.includes('"@type":"Person"'),
                        htmlContent.includes('"author"'),
                        htmlContent.includes('rel="author"'),
                        htmlContent.toLowerCase().includes('written by'),
                        htmlContent.toLowerCase().includes('author:')
                    ];
                    
                    const hasAuthor = authorChecks.some(check => check);
                    
                    if (hasAuthor) {
                        score.value += 3;
                        score.details.push('Author information present');
                        score.checks.push({ name: 'Author attribution', status: 'pass' });
                        score.debug.push('Author signals found');
                    } else {
                        score.checks.push({ name: 'Author attribution', status: 'fail' });
                        score.debug.push('No author signals detected');
                    }
                    
                    // Enhanced date detection
                    const dateChecks = [
                        doc.querySelector('meta[property="article:published_time"]'),
                        doc.querySelector('meta[property="article:modified_time"]'),
                        doc.querySelector('meta[name="publish_date"]'),
                        doc.querySelector('meta[name="date"]'),
                        doc.querySelector('meta[name="DC.date"]'),
                        doc.querySelector('time'),
                        doc.querySelector('.date, .publish-date, .published, .post-date'),
                        doc.querySelector('[itemprop="datePublished"]'),
                        doc.querySelector('[itemprop="dateModified"]'),
                        htmlContent.includes('datePublished'),
                        htmlContent.includes('dateModified')
                    ];
                    
                    const hasDate = dateChecks.some(check => check);
                    
                    if (hasDate) {
                        score.value += 2;
                        score.details.push('Publication dates found');
                        score.checks.push({ name: 'Date information', status: 'pass' });
                        score.debug.push('Date signals found');
                    } else {
                        score.checks.push({ name: 'Date information', status: 'fail' });
                    }
                    
                    // Check for structured paragraphs
                    const paragraphs = doc.querySelectorAll('p');
                    let wellStructured = 0;
                    let totalParagraphs = 0;
                    
                    paragraphs.forEach(p => {
                        const text = p.textContent.trim();
                        if (text.length > 10) {
                            totalParagraphs++;
                            if (text.length > 40 && text.length < 200) {
                                wellStructured++;
                            }
                        }
                    });
                    
                    score.debug.push(`Paragraphs: ${wellStructured}/${totalParagraphs} well-structured`);
                    
                    if (wellStructured > 5) {
                        score.value += 3;
                        score.details.push('Well-structured paragraphs');
                        score.checks.push({ name: 'Concise paragraphs', status: 'pass' });
                    } else if (wellStructured > 2) {
                        score.value += 1;
                        score.checks.push({ name: 'Concise paragraphs', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Concise paragraphs', status: 'fail' });
                    }
                    
                    // Check for internal/external links
                    const links = doc.querySelectorAll('a[href]');
                    const internalLinks = Array.from(links).filter(a => {
                        const href = a.getAttribute('href');
                        return href && (href.startsWith('/') || href.includes(baseUrl));
                    });
                    const externalLinks = Array.from(links).filter(a => {
                        const href = a.getAttribute('href');
                        return href && href.startsWith('http') && !href.includes(baseUrl);
                    });
                    
                    score.debug.push(`Links: ${internalLinks.length} internal, ${externalLinks.length} external`);
                    
                    if (links.length > 10) {
                        score.value += 2;
                        score.details.push(`Good link structure (${links.length} links)`);
                        score.checks.push({ name: 'Link citations', status: 'pass' });
                    } else if (links.length > 5) {
                        score.value += 1;
                        score.checks.push({ name: 'Link citations', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Link citations', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check citation structure');
            }
            
            return score;
        }

        async function checkAuthority(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Enhanced About page detection
                    const aboutSignals = [
                        doc.querySelector('a[href*="about"]'),
                        doc.querySelector('a[href*="About"]'),
                        doc.querySelector('a[href*="/team"]'),
                        doc.querySelector('a[href*="/company"]'),
                        doc.querySelector('a[href*="/who-we-are"]'),
                        htmlContent.toLowerCase().includes('about us'),
                        htmlContent.toLowerCase().includes('about our')
                    ];
                    
                    if (aboutSignals.some(signal => signal)) {
                        score.value += 3;
                        score.details.push('About/Company info found');
                        score.checks.push({ name: 'About page', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'About page', status: 'fail' });
                    }
                    
                    // Enhanced Contact detection
                    const contactSignals = [
                        doc.querySelector('a[href*="contact"]'),
                        doc.querySelector('a[href*="Contact"]'),
                        doc.querySelector('a[href^="mailto:"]'),
                        doc.querySelector('a[href^="tel:"]'),
                        doc.querySelector('address'),
                        htmlContent.includes('@') && htmlContent.includes('.com'),
                        htmlContent.toLowerCase().includes('contact us'),
                        htmlContent.toLowerCase().includes('get in touch')
                    ];
                    
                    if (contactSignals.some(signal => signal)) {
                        score.value += 3;
                        score.details.push('Contact information found');
                        score.checks.push({ name: 'Contact page', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Contact page', status: 'fail' });
                    }
                    
                    // Enhanced trust signals
                    const trustKeywords = [
                        'testimonial', 'review', 'trusted by', 'partner', 
                        'certified', 'accredited', 'award', 'featured in',
                        'as seen on', 'client', 'customer', 'guarantee',
                        'secure', 'verified', 'authorized'
                    ];
                    
                    const trustSignals = trustKeywords.filter(keyword => 
                        htmlContent.toLowerCase().includes(keyword)
                    );
                    
                    if (trustSignals.length > 2) {
                        score.value += 2;
                        score.details.push(`Trust signals present`);
                        score.checks.push({ name: 'Trust indicators', status: 'pass' });
                    } else if (trustSignals.length > 0) {
                        score.value += 1;
                        score.checks.push({ name: 'Trust indicators', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Trust indicators', status: 'fail' });
                    }
                    
                    // Check for SSL
                    if (baseUrl.startsWith('https')) {
                        score.value += 2;
                        score.details.push('SSL certificate active');
                        score.checks.push({ name: 'SSL/HTTPS', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'SSL/HTTPS', status: 'fail' });
                    }
                    
                    score.debug.push(`Trust signals found: ${trustSignals.length}`);
                }
            } catch (error) {
                score.details.push('Unable to check authority signals');
            }
            
            return score;
        }

        async function checkFreshness(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                // Extract domain for sitemap check
                const urlObj = new URL(baseUrl.startsWith('http') ? baseUrl : `https://${baseUrl}`);
                const sitemapUrls = [
                    `${urlObj.protocol}//${urlObj.hostname}/sitemap.xml`,
                    `${urlObj.protocol}//${urlObj.hostname}/sitemap_index.xml`,
                    `${urlObj.protocol}//${urlObj.hostname}/sitemap`
                ];
                
                let sitemapFound = false;
                let sitemapContent = null;
                
                for (const sitemapUrl of sitemapUrls) {
                    sitemapContent = await fetchWithCORS(sitemapUrl);
                    if (sitemapContent) {
                        sitemapFound = true;
                        break;
                    }
                }
                
                if (sitemapFound && sitemapContent) {
                    score.value += 3;
                    score.details.push('XML sitemap found');
                    score.checks.push({ name: 'XML sitemap', status: 'pass' });
                    
                    if (sitemapContent.includes('<lastmod>') || sitemapContent.includes('lastmod')) {
                        score.value += 2;
                        score.details.push('Sitemap includes update dates');
                        score.checks.push({ name: 'Lastmod dates', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Lastmod dates', status: 'fail' });
                    }
                } else {
                    score.checks.push({ name: 'XML sitemap', status: 'fail' });
                    score.checks.push({ name: 'Lastmod dates', status: 'fail' });
                }
                
                // Check for RSS/Atom feed
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    const feedLinks = [
                        doc.querySelector('link[type="application/rss+xml"]'),
                        doc.querySelector('link[type="application/atom+xml"]'),
                        doc.querySelector('link[type="application/feed+json"]'),
                        doc.querySelector('a[href*="/feed"]'),
                        doc.querySelector('a[href*="/rss"]'),
                        doc.querySelector('a[href*=".rss"]'),
                        doc.querySelector('a[href*="/atom"]')
                    ];
                    
                    if (feedLinks.some(link => link)) {
                        score.value += 3;
                        score.details.push('RSS/Atom feed available');
                        score.checks.push({ name: 'RSS/JSON feed', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'RSS/JSON feed', status: 'fail' });
                    }
                    
                    // Check for recent content indicators
                    const currentYear = new Date().getFullYear();
                    const recentYears = [currentYear, currentYear - 1];
                    
                    const hasRecentContent = recentYears.some(year => 
                        htmlContent.includes(year.toString())
                    );
                    
                    if (hasRecentContent) {
                        score.value += 2;
                        score.details.push('Recent content found');
                        score.checks.push({ name: 'Recent content', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Recent content', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check freshness signals');
            }
            
            return score;
        }

        async function checkTechnical(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for semantic HTML5 elements
                    const semanticElements = {
                        article: doc.querySelectorAll('article').length,
                        header: doc.querySelectorAll('header').length,
                        footer: doc.querySelectorAll('footer').length,
                        main: doc.querySelectorAll('main').length,
                        section: doc.querySelectorAll('section').length,
                        nav: doc.querySelectorAll('nav').length,
                        aside: doc.querySelectorAll('aside').length
                    };
                    
                    const semanticScore = Object.values(semanticElements).filter(count => count > 0).length;
                    
                    if (semanticScore >= 4) {
                        score.value += 4;
                        score.details.push('Excellent HTML5 structure');
                        score.checks.push({ name: 'HTML5 structure', status: 'pass' });
                    } else if (semanticScore >= 2) {
                        score.value += 2;
                        score.details.push('Basic HTML5 structure');
                        score.checks.push({ name: 'HTML5 structure', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'HTML5 structure', status: 'fail' });
                    }
                    
                    score.debug.push(`Semantic elements: ${JSON.stringify(semanticElements)}`);
                    
                    // Check for alt text on images
                    const images = doc.querySelectorAll('img');
                    const imagesWithAlt = doc.querySelectorAll('img[alt]');
                    const imagesWithGoodAlt = Array.from(imagesWithAlt).filter(img => {
                        const alt = img.getAttribute('alt');
                        return alt && alt.trim().length > 3 && !alt.toLowerCase().includes('image');
                    });
                    
                    if (images.length > 0) {
                        const altCoverage = imagesWithAlt.length / images.length;
                        const goodAltCoverage = imagesWithGoodAlt.length / images.length;
                        
                        if (goodAltCoverage > 0.7) {
                            score.value += 3;
                            score.details.push('Excellent alt text coverage');
                            score.checks.push({ name: 'Image alt text', status: 'pass' });
                        } else if (altCoverage > 0.5) {
                            score.value += 1;
                            score.details.push('Partial alt text coverage');
                            score.checks.push({ name: 'Image alt text', status: 'partial' });
                        } else {
                            score.checks.push({ name: 'Image alt text', status: 'fail' });
                        }
                        
                        score.debug.push(`Images: ${images.length} total, ${imagesWithAlt.length} with alt, ${imagesWithGoodAlt.length} with good alt`);
                    } else {
                        score.value += 1;
                        score.details.push('No images to check');
                        score.checks.push({ name: 'Image alt text', status: 'pass' });
                    }
                    
                    // Check mobile viewport and responsive design
                    const viewport = doc.querySelector('meta[name="viewport"]');
                    const hasResponsiveImages = doc.querySelector('img[srcset], picture');
                    const hasMediaQueries = htmlContent.includes('@media');
                    
                    if (viewport) {
                        score.value += 3;
                        score.details.push('Mobile-optimized');
                        score.checks.push({ name: 'Mobile ready', status: 'pass' });
                        
                        if (hasResponsiveImages || hasMediaQueries) {
                            score.debug.push('Advanced responsive features detected');
                        }
                    } else {
                        score.checks.push({ name: 'Mobile ready', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check technical signals');
            }
            
            return score;
        }

        async function checkContentFormat(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Enhanced FAQ detection
                    const faqSignals = [
                        htmlContent.toLowerCase().includes('frequently asked'),
                        htmlContent.toLowerCase().includes('faq'),
                        htmlContent.includes('"@type":"FAQPage"'),
                        htmlContent.includes('"@type":"Question"'),
                        doc.querySelector('.faq, #faq, [class*="faq"], [id*="faq"]'),
                        doc.querySelector('dl'),
                        Array.from(doc.querySelectorAll('h2, h3, h4')).some(h => 
                            h.textContent.toLowerCase().includes('?')
                        )
                    ];
                    
                    if (faqSignals.filter(signal => signal).length >= 2) {
                        score.value += 3;
                        score.details.push('FAQ/Q&A content found');
                        score.checks.push({ name: 'FAQ content', status: 'pass' });
                    } else if (faqSignals.some(signal => signal)) {
                        score.value += 1;
                        score.checks.push({ name: 'FAQ content', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'FAQ content', status: 'fail' });
                    }
                    
                    // Check for lists and tables
                    const lists = doc.querySelectorAll('ul, ol');
                    const tables = doc.querySelectorAll('table');
                    const definitionLists = doc.querySelectorAll('dl');
                    
                    const structuredContent = lists.length + tables.length + definitionLists.length;
                    
                    if (structuredContent > 5) {
                        score.value += 3;
                        score.details.push(`Rich structured content (${structuredContent} elements)`);
                        score.checks.push({ name: 'Lists/Tables', status: 'pass' });
                    } else if (structuredContent > 2) {
                        score.value += 1;
                        score.checks.push({ name: 'Lists/Tables', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Lists/Tables', status: 'fail' });
                    }
                    
                    score.debug.push(`Structured content: ${lists.length} lists, ${tables.length} tables, ${definitionLists.length} dl`);
                    
                    // Check for definitions or glossary
                    const definitionSignals = [
                        doc.querySelector('dl'),
                        doc.querySelector('[class*="glossary"], [id*="glossary"]'),
                        doc.querySelector('[class*="definition"], [id*="definition"]'),
                        doc.querySelector('[class*="dictionary"], [id*="dictionary"]'),
                        htmlContent.toLowerCase().includes('definition'),
                        htmlContent.toLowerCase().includes('glossary'),
                        htmlContent.toLowerCase().includes('means that'),
                        htmlContent.toLowerCase().includes('refers to')
                    ];
                    
                    if (definitionSignals.filter(signal => signal).length >= 2) {
                        score.value += 2;
                        score.details.push('Definitions/glossary present');
                        score.checks.push({ name: 'Definitions', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Definitions', status: 'fail' });
                    }
                    
                    // Check content depth
                    const textContent = doc.body ? doc.body.textContent : '';
                    const words = textContent.split(/\s+/).filter(word => word.length > 2);
                    const wordCount = words.length;
                    
                    if (wordCount > 1000) {
                        score.value += 2;
                        score.details.push(`Comprehensive content (${wordCount}+ words)`);
                        score.checks.push({ name: 'Content depth', status: 'pass' });
                    } else if (wordCount > 500) {
                        score.value += 1;
                        score.details.push(`Moderate content (${wordCount} words)`);
                        score.checks.push({ name: 'Content depth', status: 'partial' });
                    } else {
                        score.details.push(`Thin content (${wordCount} words)`);
                        score.checks.push({ name: 'Content depth', status: 'fail' });
                    }
                    
                    score.debug.push(`Word count: ${wordCount}`);
                }
            } catch (error) {
                score.details.push('Unable to check content formats');
            }
            
            return score;
        }

        async function checkLicensing(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                // Extract domain for robots.txt check
                const urlObj = new URL(baseUrl.startsWith('http') ? baseUrl : `https://${baseUrl}`);
                const robotsUrl = `${urlObj.protocol}//${urlObj.hostname}/robots.txt`;
                const robotsContent = await fetchWithCORS(robotsUrl);
                
                if (robotsContent) {
                    // Check for training vs retrieval bot differentiation
                    const bots = {
                        training: ['GPTBot', 'CCBot', 'ChatGPT-User', 'Claude-Web'],
                        search: ['OAI-SearchBot', 'ChatGPT-User', 'PerplexityBot', 'YouBot']
                    };
                    
                    const hasTrainingBots = bots.training.some(bot => 
                        robotsContent.includes(bot)
                    );
                    const hasSearchBots = bots.search.some(bot => 
                        robotsContent.includes(bot)
                    );
                    
                    if (hasTrainingBots && hasSearchBots) {
                        score.value += 4;
                        score.details.push('Differentiates bot types');
                        score.checks.push({ name: 'Bot differentiation', status: 'pass' });
                    } else if (hasTrainingBots || hasSearchBots) {
                        score.value += 2;
                        score.details.push('Some bot differentiation');
                        score.checks.push({ name: 'Bot differentiation', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Bot differentiation', status: 'fail' });
                    }
                    
                    if (robotsContent.toLowerCase().includes('llms.txt')) {
                        score.value += 3;
                        score.details.push('llms.txt configured');
                        score.checks.push({ name: 'llms.txt policy', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'llms.txt policy', status: 'fail' });
                    }
                }
                
                // Check for terms/license page
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const licenseSignals = [
                        htmlContent.toLowerCase().includes('terms of service'),
                        htmlContent.toLowerCase().includes('terms of use'),
                        htmlContent.toLowerCase().includes('terms and conditions'),
                        htmlContent.toLowerCase().includes('license'),
                        htmlContent.toLowerCase().includes('copyright'),
                        htmlContent.toLowerCase().includes('creative commons'),
                        htmlContent.toLowerCase().includes('privacy policy'),
                        htmlContent.includes('©'),
                        htmlContent.includes('&copy;')
                    ];
                    
                    const licenseCount = licenseSignals.filter(signal => signal).length;
                    
                    if (licenseCount >= 3) {
                        score.value += 3;
                        score.details.push('Strong license/terms presence');
                        score.checks.push({ name: 'Terms/License', status: 'pass' });
                    } else if (licenseCount >= 1) {
                        score.value += 1;
                        score.details.push('Basic license/terms present');
                        score.checks.push({ name: 'Terms/License', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Terms/License', status: 'fail' });
                    }
                    
                    score.debug.push(`License signals: ${licenseCount}`);
                }
            } catch (error) {
                score.details.push('Unable to check licensing');
            }
            
            return score;
        }

        function updateProgress(percent, message) {
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = percent + '%';
            progressBar.textContent = percent + '%';
            
            const loadingSection = document.getElementById('loadingSection');
            const statusText = loadingSection.querySelector('p');
            if (message) {
                statusText.textContent = message;
            }
        }

        function calculateTotalScore() {
            let total = 0;
            for (const factor in analysisResults.factors) {
                total += analysisResults.factors[factor].value;
            }
            analysisResults.totalScore = Math.round(total);
        }

        function animateScore(targetScore) {
            const scoreElement = document.getElementById('totalScore');
            const scoreCircle = document.getElementById('scoreCircle');
            const scoreStatus = document.getElementById('scoreStatus');
            
            // Animate number
            let currentScore = 0;
            const increment = targetScore / 50;
            const timer = setInterval(() => {
                currentScore += increment;
                if (currentScore >= targetScore) {
                    currentScore = targetScore;
                    clearInterval(timer);
                }
                scoreElement.textContent = Math.round(currentScore);
            }, 20);
            
            // Animate circle (adjusted for max score of 80)
            const circumference = 2 * Math.PI * 90;
            const offset = circumference - (targetScore / 80) * circumference;
            scoreCircle.style.strokeDashoffset = offset;
            
            // Set status message
            scoreStatus.textContent = getStatus(targetScore);
            scoreStatus.style.color = getStatusColor(targetScore);
        }

        function displayFactors() {
            const factorsGrid = document.getElementById('factorsGrid');
            factorsGrid.innerHTML = '';
            
            const factorNames = {
                botAccessibility: 'Bot Accessibility',
                parsability: 'Parsability & Structure',
                citationFriendliness: 'Citation Friendliness',
                authority: 'Authority & Trust',
                freshness: 'Freshness & Feeds',
                technical: 'Technical Signals',
                contentFormat: 'Content Format',
                licensing: 'Licensing Readiness'
            };
            
            for (const [key, factor] of Object.entries(analysisResults.factors)) {
                const card = createFactorCard(factorNames[key], factor);
                factorsGrid.appendChild(card);
            }
        }

        function createFactorCard(name, factor) {
            const card = document.createElement('div');
            card.className = 'factor-card';
            
            const scoreColor = factor.value >= 8 ? '#4caf50' : 
                             factor.value >= 5 ? '#ff9800' : '#f44336';
            
            const debugInfo = factor.debug && factor.debug.length > 0 
                ? `<div class="debug-info">Debug: ${factor.debug.join(' | ')}</div>` 
                : '';
            
            card.innerHTML = `
                <div class="factor-header">
                    <div class="factor-title">${name}</div>
                    <div class="factor-score" style="color: ${scoreColor}">${factor.value}/${factor.max}</div>
                </div>
                <div class="factor-details">${factor.details.join(', ') || 'No details available'}</div>
                <ul class="factor-items">
                    ${factor.checks.map(check => `
                        <li>
                            <span class="check-icon ${check.status}">
                                ${check.status === 'pass' ? '✓' : check.status === 'partial' ? '~' : '✗'}
                            </span>
                            ${check.name}
                        </li>
                    `).join('')}
                </ul>
                ${debugInfo}
            `;
            
            return card;
        }

        function generateAllRecommendations() {
            const recommendations = document.getElementById('recommendations');
            const html = generateRecommendationsHTML();
            recommendations.innerHTML = html;
        }

        function generateRecommendationsHTML() {
            const factorInfo = {
                botAccessibility: {
                    name: 'Bot Accessibility',
                    explanation: 'AI assistants need permission to access and read your website. Without proper bot access, ChatGPT, Claude, and other AI tools cannot discover or reference your content.',
                    whyImportant: 'If AI bots cannot access your site, your content will never appear in AI-generated responses, missing a growing source of traffic and visibility.'
                },
                parsability: {
                    name: 'Parsability & Structure',
                    explanation: 'AI systems need clear, semantic HTML structure to understand your content hierarchy and meaning. This includes proper headings, schema markup, and semantic HTML5 tags.',
                    whyImportant: 'Well-structured content helps AI understand what your page is about, making it more likely to be cited accurately in relevant queries.'
                },
                citationFriendliness: {
                    name: 'Citation Friendliness',
                    explanation: 'AI systems prefer content they can easily quote and attribute. This includes clear authorship, dates, and bite-sized information chunks.',
                    whyImportant: 'Citation-friendly content is more likely to be quoted verbatim in AI responses, with proper attribution driving traffic back to your site.'
                },
                authority: {
                    name: 'Authority & Trust',
                    explanation: 'AI systems evaluate trustworthiness through signals like SSL certificates, contact information, about pages, and social proof.',
                    whyImportant: 'AI prioritizes authoritative sources to ensure accuracy. Higher trust signals mean your content is more likely to be selected over competitors.'
                },
                freshness: {
                    name: 'Freshness & Feeds',
                    explanation: 'AI systems need to know when content was published and updated. Sitemaps, RSS feeds, and date stamps help AI identify current information.',
                    whyImportant: 'For time-sensitive queries, AI will prefer sources with clear recency signals. Outdated-looking content gets ignored.'
                },
                technical: {
                    name: 'Technical Signals',
                    explanation: 'Technical optimization ensures AI can efficiently process your site. This includes semantic HTML5, proper alt text, and mobile optimization.',
                    whyImportant: 'Technical issues can prevent AI from properly parsing your content, even if the information is valuable.'
                },
                contentFormat: {
                    name: 'Content Format & Coverage',
                    explanation: 'AI systems prefer certain content formats like FAQs, lists, tables, and comprehensive coverage of topics.',
                    whyImportant: 'Well-formatted content is easier for AI to extract and present to users. FAQ sections are particularly valuable for question-based queries.'
                },
                licensing: {
                    name: 'Licensing & Policy Readiness',
                    explanation: 'Clear licensing and bot policies tell AI systems how they can use your content. This includes robots.txt differentiation and terms of service.',
                    whyImportant: 'As AI companies establish content partnerships, sites with clear licensing policies will have advantages in visibility and potential revenue.'
                }
            };
            
            let html = '<h2>📋 Complete Analysis & Recommendations</h2>';
            
            for (const [key, factor] of Object.entries(analysisResults.factors)) {
                const info = factorInfo[key];
                const score = factor.value;
                const maxScore = factor.max;
                const percentage = Math.round((score / maxScore) * 100);
                
                let priority = 'low';
                let priorityText = 'Low Priority';
                if (percentage < 40) {
                    priority = 'high';
                    priorityText = 'High Priority - Fix Soon';
                } else if (percentage < 70) {
                    priority = 'medium';
                    priorityText = 'Medium Priority';
                }
                
                const rec = getRecommendation(key, factor);
                
                html += `
                    <div class="factor-section">
                        <h3>
                            ${info.name}
                            <span style="font-size: 1rem; color: ${percentage >= 70 ? '#4caf50' : percentage >= 40 ? '#ff9800' : '#f44336'}">
                                ${score}/${maxScore} (${percentage}%)
                            </span>
                        </h3>
                        
                        <div class="factor-explanation">
                            <strong>What this measures:</strong> ${info.explanation}
                            <br><br>
                            <strong>Why it matters:</strong> ${info.whyImportant}
                        </div>
                        
                        <div class="recommendation-item">
                            <span class="recommendation-priority priority-${priority}">${priorityText}</span>
                            <div class="recommendation-title">${rec.title}</div>
                            <p>${rec.description}</p>
                            <ol class="recommendation-steps">
                                ${rec.steps.map(step => `<li>${step}</li>`).join('')}
                            </ol>
                        </div>
                    </div>
                `;
            }
            
            return html;
        }

        function getRecommendation(factorKey, factor) {
            const recommendations = {
                botAccessibility: {
                    title: 'Optimize Bot Accessibility',
                    description: 'Ensure AI bots can discover and access your content.',
                    steps: [
                        'Create or update your robots.txt file in the root directory',
                        'Add specific allow rules for AI bots: GPTBot, ClaudeBot, ChatGPT-User, OAI-SearchBot, PerplexityBot',
                        'Create an llms.txt file highlighting your best content for AI systems',
                        'Consider differentiating between training bots (GPTBot) and retrieval bots (OAI-SearchBot)',
                        'Test your robots.txt at Google\'s robots.txt tester',
                        'Monitor server logs to verify AI bots are visiting your site'
                    ]
                },
                parsability: {
                    title: 'Improve Content Structure',
                    description: 'Make your content easily understandable for AI parsers.',
                    steps: [
                        'Add one clear H1 tag per page describing the main topic',
                        'Create logical heading hierarchy (H1 → H2 → H3) for content sections',
                        'Implement Schema.org JSON-LD markup for your content type',
                        'Use semantic HTML5 tags: <article>, <main>, <section>, <nav>, <aside>',
                        'Add structured data for articles, FAQs, or products as appropriate',
                        'Validate your schema markup using Google\'s Rich Results Test',
                        'Ensure your HTML validates at validator.w3.org'
                    ]
                },
                citationFriendliness: {
                    title: 'Enhance Citation Potential',
                    description: 'Make your content easy for AI to quote and attribute.',
                    steps: [
                        'Add author meta tags: <meta name="author" content="Name">',
                        'Include publication and update dates in both visible text and meta tags',
                        'Break content into concise 40-120 word paragraphs with clear points',
                        'Add bylines with author credentials and expertise',
                        'Include both internal links (to related content) and external citations',
                        'Use <time> tags for dates with datetime attributes',
                        'Add Schema.org Article markup with author and date information'
                    ]
                },
                authority: {
                    title: 'Build Trust Signals',
                    description: 'Establish your site as a trustworthy source for AI systems.',
                    steps: [
                        'Create comprehensive About and Team pages with credentials',
                        'Add clear Contact page with multiple contact methods',
                        'Ensure HTTPS is enabled across your entire site',
                        'Display testimonials, reviews, or case studies prominently',
                        'List partnerships, certifications, or awards',
                        'Add author bio boxes to content with expertise indicators',
                        'Include privacy policy and terms of service pages',
                        'Register with Google Business Profile if applicable'
                    ]
