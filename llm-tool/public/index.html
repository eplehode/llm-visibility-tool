<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Visibility Diagnosis Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.95;
        }

        .input-section {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .input-group {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        input[type="text"] {
            flex: 1;
            padding: 15px 20px;
            font-size: 1.1rem;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            transition: all 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
        }

        .analyze-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102,126,234,0.3);
        }

        .analyze-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-section {
            display: none;
        }

        .results-section.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .overall-score {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .score-circle {
            width: 200px;
            height: 200px;
            margin: 0 auto 20px;
            position: relative;
        }

        .score-circle svg {
            transform: rotate(-90deg);
        }

        .score-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #333;
        }

        .score-label {
            font-size: 1.3rem;
            color: #666;
            margin-bottom: 10px;
        }

        .score-status {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 10px;
        }

        .factors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .factor-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            transition: all 0.3s;
        }

        .factor-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.12);
        }

        .factor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .factor-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
        }

        .factor-score {
            font-size: 1.3rem;
            font-weight: bold;
            padding: 5px 15px;
            border-radius: 20px;
            background: #f5f5f5;
        }

        .factor-details {
            color: #666;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .factor-items {
            list-style: none;
        }

        .factor-items li {
            padding: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .check-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }

        .check-icon.pass {
            background: #4caf50;
        }

        .check-icon.fail {
            background: #f44336;
        }

        .check-icon.partial {
            background: #ff9800;
        }

        .recommendations {
            background: white;
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .recommendations h2 {
            color: #333;
            margin-bottom: 25px;
            font-size: 1.8rem;
        }

        .factor-section {
            margin-bottom: 40px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 4px solid #667eea;
        }

        .factor-section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .factor-explanation {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 0.95rem;
            color: #555;
            line-height: 1.6;
        }

        .recommendation-item {
            background: white;
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 10px;
            border-left: 3px solid #764ba2;
        }

        .recommendation-priority {
            display: inline-block;
            padding: 5px 15px;
            background: #667eea;
            color: white;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .priority-high {
            background: #f44336;
        }

        .priority-medium {
            background: #ff9800;
        }

        .priority-low {
            background: #4caf50;
        }

        .recommendation-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .recommendation-steps {
            margin-top: 15px;
            padding-left: 20px;
        }

        .recommendation-steps li {
            margin-bottom: 8px;
            color: #666;
            line-height: 1.6;
        }

        .debug-info {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.85rem;
            margin-top: 10px;
            font-family: monospace;
        }

        .loading {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 20px;
            margin-bottom: 30px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #c62828;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #f5f5f5;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 15px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ¤– LLM Visibility Diagnosis Tool</h1>
            <p>Analyze how well AI assistants can discover, understand, and cite your website</p>
            <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 5px;">8 Real Factors â€¢ 100% Verified Analysis â€¢ Complete Recommendations</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <input type="text" id="domainInput" placeholder="Enter domain (e.g., example.com)" />
                <button class="analyze-btn" onclick="analyzeDomain()">Analyze Website</button>
            </div>
        </div>

        <div id="loadingSection" class="loading" style="display: none;">
            <div class="spinner"></div>
            <p>Analyzing website visibility for AI assistants...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%">0%</div>
            </div>
        </div>

        <div id="errorSection" style="display: none;">
            <div class="error-message" id="errorMessage"></div>
        </div>

        <div id="resultsSection" class="results-section">
            <div class="overall-score">
                <div class="score-circle">
                    <svg width="200" height="200">
                        <circle cx="100" cy="100" r="90" stroke="#e0e0e0" stroke-width="20" fill="none"/>
                        <circle id="scoreCircle" cx="100" cy="100" r="90" stroke="url(#gradient)" stroke-width="20" fill="none" 
                                stroke-dasharray="565" stroke-dashoffset="565" stroke-linecap="round"/>
                        <defs>
                            <linearGradient id="gradient">
                                <stop offset="0%" stop-color="#667eea"/>
                                <stop offset="100%" stop-color="#764ba2"/>
                            </linearGradient>
                        </defs>
                    </svg>
                    <div class="score-number" id="totalScore">0</div>
                </div>
                <div class="score-label">LLM Visibility Score (out of 80)</div>
                <div class="score-status" id="scoreStatus">Calculating...</div>
            </div>

            <div class="factors-grid" id="factorsGrid"></div>

            <div class="recommendations" id="recommendations"></div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION - YOUR VERCEL URL IS HERE! =====
        const PROXY_BASE_URL = 'https://llm-visibility-tool-chi.vercel.app/api/analyze';
        
        // Configuration for bot checking
        const AI_BOTS = ['GPTBot', 'OAI-SearchBot', 'ClaudeBot', 'PerplexityBot', 'ChatGPT-User', 'CCBot', 'Amazonbot', 'Applebot'];
        
        let analysisResults = {};

        async function analyzeDomain() {
            const domainInput = document.getElementById('domainInput');
            const domain = domainInput.value.trim().replace(/^https?:\/\//, '').replace(/\/$/, '');
            
            if (!domain) {
                showError('Please enter a valid domain');
                return;
            }

            // Reset and show loading
            document.getElementById('resultsSection').classList.remove('active');
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('loadingSection').style.display = 'block';
            
            try {
                await performAnalysis(domain);
            } catch (error) {
                showError(`Analysis failed: ${error.message}. Please ensure the domain is accessible and try again.`);
            } finally {
                document.getElementById('loadingSection').style.display = 'none';
            }
        }

        async function performAnalysis(domain) {
            analysisResults = {
                domain: domain,
                factors: {},
                totalScore: 0
            };

            const baseUrl = `https://${domain}`;
            
            // Update progress
            updateProgress(12, 'Checking bot accessibility...');
            analysisResults.factors.botAccessibility = await checkBotAccessibility(baseUrl);
            
            updateProgress(24, 'Analyzing content structure...');
            analysisResults.factors.parsability = await checkParsability(baseUrl);
            
            updateProgress(36, 'Evaluating citation friendliness...');
            analysisResults.factors.citationFriendliness = await checkCitationFriendliness(baseUrl);
            
            updateProgress(48, 'Assessing authority signals...');
            analysisResults.factors.authority = await checkAuthority(baseUrl);
            
            updateProgress(60, 'Checking content freshness...');
            analysisResults.factors.freshness = await checkFreshness(baseUrl);
            
            updateProgress(72, 'Analyzing technical signals...');
            analysisResults.factors.technical = await checkTechnical(baseUrl);
            
            updateProgress(84, 'Reviewing content formats...');
            analysisResults.factors.contentFormat = await checkContentFormat(baseUrl);
            
            updateProgress(96, 'Checking licensing readiness...');
            analysisResults.factors.licensing = await checkLicensing(baseUrl);
            
            updateProgress(100, 'Generating report...');
            
            // Calculate total score
            calculateTotalScore();
            
            // Display results
            displayResults();
        }

        async function fetchWithCORS(url, type = 'html') {
            try {
                // Extract domain from URL if it's a full URL
                let domain = url.replace(/^https?:\/\//, '').replace(/\/$/, '');
                
                // For specific resources, extract just the domain
                if (url.includes('/robots.txt')) {
                    domain = new URL(url).hostname;
                    type = 'robots';
                } else if (url.includes('/sitemap.xml')) {
                    domain = new URL(url).hostname;
                    type = 'sitemap';
                } else if (url.includes('/llms.txt')) {
                    domain = new URL(url).hostname;
                    type = 'llms';
                }
                
                // Call your Vercel proxy
                const proxyUrl = `${PROXY_BASE_URL}?url=${encodeURIComponent(domain)}&type=${type}`;
                console.log('Fetching via proxy:', proxyUrl);
                
                const response = await fetch(proxyUrl);
                const data = await response.json();
                
                if (data.success) {
                    return data.content;
                } else {
                    console.error('Proxy error:', data.error);
                    return null;
                }
            } catch (error) {
                console.error('Fetch error:', error);
                return null;
            }
        }

        async function checkBotAccessibility(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                // Check robots.txt
                const robotsUrl = `${baseUrl}/robots.txt`;
                const robotsContent = await fetchWithCORS(robotsUrl);
                
                if (robotsContent) {
                    score.details.push('robots.txt found');
                    score.checks.push({ name: 'robots.txt exists', status: 'pass' });
                    score.value += 3;
                    
                    // Check for AI bot allowances
                    const allowedBots = AI_BOTS.filter(bot => {
                        // Check if bot is NOT explicitly disallowed
                        const disallowPattern = new RegExp(`User-agent:\\s*${bot}\\s*\\nDisallow:\\s*/`, 'i');
                        const allowPattern = new RegExp(`User-agent:\\s*${bot}\\s*\\nAllow:\\s*/`, 'i');
                        const isDisallowed = disallowPattern.test(robotsContent);
                        const isAllowed = allowPattern.test(robotsContent);
                        
                        // Also check for wildcard allowance
                        const wildcardAllow = robotsContent.includes('User-agent: *') && 
                                            !robotsContent.includes('Disallow: /');
                        
                        return isAllowed || (!isDisallowed && wildcardAllow);
                    });
                    
                    score.debug.push(`Found ${allowedBots.length} allowed bots: ${allowedBots.join(', ')}`);
                    
                    if (allowedBots.length > 0) {
                        score.value += Math.min(4, allowedBots.length);
                        score.details.push(`${allowedBots.length} AI bots allowed`);
                        score.checks.push({ name: 'AI bots allowed', status: allowedBots.length > 2 ? 'pass' : 'partial' });
                    } else {
                        score.checks.push({ name: 'AI bots allowed', status: 'fail' });
                    }
                    
                    // Check for llms.txt reference
                    if (robotsContent.toLowerCase().includes('llms.txt')) {
                        score.value += 2;
                        score.details.push('llms.txt reference found');
                        score.checks.push({ name: 'llms.txt configured', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'llms.txt configured', status: 'fail' });
                    }
                } else {
                    score.checks.push({ name: 'robots.txt exists', status: 'fail' });
                    score.checks.push({ name: 'AI bots allowed', status: 'fail' });
                    score.checks.push({ name: 'llms.txt configured', status: 'fail' });
                }
                
                // Check for llms.txt directly
                try {
                    const llmsUrl = `${baseUrl}/llms.txt`;
                    const llmsContent = await fetchWithCORS(llmsUrl);
                    if (llmsContent) {
                        score.value += 1;
                        score.details.push('llms.txt file exists');
                    }
                } catch (e) {
                    // llms.txt not found
                }
                
            } catch (error) {
                score.details.push('Unable to check bot accessibility');
            }
            
            return score;
        }

        async function checkParsability(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for proper heading structure
                    const h1Count = doc.querySelectorAll('h1').length;
                    const h2Count = doc.querySelectorAll('h2').length;
                    const h3Count = doc.querySelectorAll('h3').length;
                    
                    score.debug.push(`Found: ${h1Count} H1s, ${h2Count} H2s, ${h3Count} H3s`);
                    
                    if (h1Count > 0) {
                        score.value += 2;
                        score.details.push(`${h1Count} H1 tag(s) found`);
                        score.checks.push({ name: 'H1 headings present', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'H1 headings present', status: 'fail' });
                    }
                    
                    if (h2Count > 0 && h3Count > 0) {
                        score.value += 3;
                        score.details.push('Hierarchical heading structure');
                        score.checks.push({ name: 'H2-H3 hierarchy', status: 'pass' });
                    } else if (h2Count > 0) {
                        score.value += 1;
                        score.checks.push({ name: 'H2-H3 hierarchy', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'H2-H3 hierarchy', status: 'fail' });
                    }
                    
                    // Check for schema markup (multiple ways)
                    const schemaScripts = doc.querySelectorAll('script[type="application/ld+json"]');
                    const microdataItems = doc.querySelectorAll('[itemscope]');
                    const rdfa = doc.querySelectorAll('[typeof]');
                    
                    if (schemaScripts.length > 0 || microdataItems.length > 0 || rdfa.length > 0) {
                        score.value += 3;
                        score.details.push('Schema/structured markup found');
                        score.checks.push({ name: 'Schema.org markup', status: 'pass' });
                        score.debug.push(`Schema: ${schemaScripts.length} JSON-LD, ${microdataItems.length} microdata, ${rdfa.length} RDFa`);
                    } else {
                        score.checks.push({ name: 'Schema.org markup', status: 'fail' });
                    }
                    
                    // Check for semantic HTML
                    const semanticElements = {
                        article: doc.querySelectorAll('article').length,
                        main: doc.querySelectorAll('main').length,
                        nav: doc.querySelectorAll('nav').length,
                        section: doc.querySelectorAll('section').length,
                        aside: doc.querySelectorAll('aside').length,
                        header: doc.querySelectorAll('header').length,
                        footer: doc.querySelectorAll('footer').length
                    };
                    
                    const totalSemantic = Object.values(semanticElements).reduce((a, b) => a + b, 0);
                    
                    if (totalSemantic >= 3) {
                        score.value += 2;
                        score.details.push('Good semantic HTML structure');
                        score.checks.push({ name: 'Semantic HTML tags', status: 'pass' });
                    } else if (totalSemantic >= 1) {
                        score.value += 1;
                        score.checks.push({ name: 'Semantic HTML tags', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Semantic HTML tags', status: 'fail' });
                    }
                    
                    score.debug.push(`Semantic elements: ${JSON.stringify(semanticElements)}`);
                }
            } catch (error) {
                score.details.push('Unable to analyze page structure');
            }
            
            return score;
        }

        async function checkCitationFriendliness(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Enhanced author detection
                    const authorChecks = [
                        doc.querySelector('meta[name="author"]'),
                        doc.querySelector('meta[property="article:author"]'),
                        doc.querySelector('meta[name="dc.creator"]'),
                        doc.querySelector('meta[property="og:author"]'),
                        doc.querySelector('link[rel="author"]'),
                        doc.querySelector('[rel="author"]'),
                        doc.querySelector('.author, .by-author, .byline, .by, .written-by'),
                        doc.querySelector('[itemprop="author"]'),
                        doc.querySelector('address'),
                        htmlContent.includes('"@type":"Person"'),
                        htmlContent.includes('"author"'),
                        htmlContent.includes('rel="author"'),
                        htmlContent.toLowerCase().includes('written by'),
                        htmlContent.toLowerCase().includes('author:')
                    ];
                    
                    const hasAuthor = authorChecks.some(check => check);
                    
                    if (hasAuthor) {
                        score.value += 3;
                        score.details.push('Author information present');
                        score.checks.push({ name: 'Author attribution', status: 'pass' });
                        score.debug.push('Author signals found');
                    } else {
                        score.checks.push({ name: 'Author attribution', status: 'fail' });
                        score.debug.push('No author signals detected');
                    }
                    
                    // Enhanced date detection
                    const dateChecks = [
                        doc.querySelector('meta[property="article:published_time"]'),
                        doc.querySelector('meta[property="article:modified_time"]'),
                        doc.querySelector('meta[name="publish_date"]'),
                        doc.querySelector('meta[name="date"]'),
                        doc.querySelector('meta[name="DC.date"]'),
                        doc.querySelector('time'),
                        doc.querySelector('.date, .publish-date, .published, .post-date'),
                        doc.querySelector('[itemprop="datePublished"]'),
                        doc.querySelector('[itemprop="dateModified"]'),
                        htmlContent.includes('datePublished'),
                        htmlContent.includes('dateModified')
                    ];
                    
                    const hasDate = dateChecks.some(check => check);
                    
                    if (hasDate) {
                        score.value += 2;
                        score.details.push('Publication dates found');
                        score.checks.push({ name: 'Date information', status: 'pass' });
                        score.debug.push('Date signals found');
                    } else {
                        score.checks.push({ name: 'Date information', status: 'fail' });
                    }
                    
                    // Check for structured paragraphs
                    const paragraphs = doc.querySelectorAll('p');
                    let wellStructured = 0;
                    let totalParagraphs = 0;
                    
                    paragraphs.forEach(p => {
                        const text = p.textContent.trim();
                        if (text.length > 10) {
                            totalParagraphs++;
                            if (text.length > 40 && text.length < 200) {
                                wellStructured++;
                            }
                        }
                    });
                    
                    score.debug.push(`Paragraphs: ${wellStructured}/${totalParagraphs} well-structured`);
                    
                    if (wellStructured > 5) {
                        score.value += 3;
                        score.details.push('Well-structured paragraphs');
                        score.checks.push({ name: 'Concise paragraphs', status: 'pass' });
                    } else if (wellStructured > 2) {
                        score.value += 1;
                        score.checks.push({ name: 'Concise paragraphs', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Concise paragraphs', status: 'fail' });
                    }
                    
                    // Check for internal/external links
                    const links = doc.querySelectorAll('a[href]');
                    const internalLinks = Array.from(links).filter(a => {
                        const href = a.getAttribute('href');
                        return href && (href.startsWith('/') || href.includes(baseUrl));
                    });
                    const externalLinks = Array.from(links).filter(a => {
                        const href = a.getAttribute('href');
                        return href && href.startsWith('http') && !href.includes(baseUrl);
                    });
                    
                    score.debug.push(`Links: ${internalLinks.length} internal, ${externalLinks.length} external`);
                    
                    if (links.length > 10) {
                        score.value += 2;
                        score.details.push(`Good link structure (${links.length} links)`);
                        score.checks.push({ name: 'Link citations', status: 'pass' });
                    } else if (links.length > 5) {
                        score.value += 1;
                        score.checks.push({ name: 'Link citations', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Link citations', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check citation structure');
            }
            
            return score;
        }

        async function checkAuthority(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Enhanced About page detection
                    const aboutSignals = [
                        doc.querySelector('a[href*="about"]'),
                        doc.querySelector('a[href*="About"]'),
                        doc.querySelector('a[href*="/team"]'),
                        doc.querySelector('a[href*="/company"]'),
                        doc.querySelector('a[href*="/who-we-are"]'),
                        htmlContent.toLowerCase().includes('about us'),
                        htmlContent.toLowerCase().includes('about our')
                    ];
                    
                    if (aboutSignals.some(signal => signal)) {
                        score.value += 3;
                        score.details.push('About/Company info found');
                        score.checks.push({ name: 'About page', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'About page', status: 'fail' });
                    }
                    
                    // Enhanced Contact detection
                    const contactSignals = [
                        doc.querySelector('a[href*="contact"]'),
                        doc.querySelector('a[href*="Contact"]'),
                        doc.querySelector('a[href^="mailto:"]'),
                        doc.querySelector('a[href^="tel:"]'),
                        doc.querySelector('address'),
                        htmlContent.includes('@') && htmlContent.includes('.com'),
                        htmlContent.toLowerCase().includes('contact us'),
                        htmlContent.toLowerCase().includes('get in touch')
                    ];
                    
                    if (contactSignals.some(signal => signal)) {
                        score.value += 3;
                        score.details.push('Contact information found');
                        score.checks.push({ name: 'Contact page', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Contact page', status: 'fail' });
                    }
                    
                    // Enhanced trust signals
                    const trustKeywords = [
                        'testimonial', 'review', 'trusted by', 'partner', 
                        'certified', 'accredited', 'award', 'featured in',
                        'as seen on', 'client', 'customer', 'guarantee',
                        'secure', 'verified', 'authorized'
                    ];
                    
                    const trustSignals = trustKeywords.filter(keyword => 
                        htmlContent.toLowerCase().includes(keyword)
                    );
                    
                    if (trustSignals.length > 2) {
                        score.value += 2;
                        score.details.push(`Trust signals present (${trustSignals.join(', ')})`);
                        score.checks.push({ name: 'Trust indicators', status: 'pass' });
                    } else if (trustSignals.length > 0) {
                        score.value += 1;
                        score.checks.push({ name: 'Trust indicators', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Trust indicators', status: 'fail' });
                    }
                    
                    // Check for SSL
                    if (baseUrl.startsWith('https')) {
                        score.value += 2;
                        score.details.push('SSL certificate active');
                        score.checks.push({ name: 'SSL/HTTPS', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'SSL/HTTPS', status: 'fail' });
                    }
                    
                    score.debug.push(`Trust signals found: ${trustSignals.length}`);
                }
            } catch (error) {
                score.details.push('Unable to check authority signals');
            }
            
            return score;
        }

        async function checkFreshness(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                // Check for sitemap
                const sitemapUrls = [
                    `${baseUrl}/sitemap.xml`,
                    `${baseUrl}/sitemap_index.xml`,
                    `${baseUrl}/sitemap`
                ];
                
                let sitemapFound = false;
                let sitemapContent = null;
                
                for (const sitemapUrl of sitemapUrls) {
                    sitemapContent = await fetchWithCORS(sitemapUrl);
                    if (sitemapContent) {
                        sitemapFound = true;
                        break;
                    }
                }
                
                if (sitemapFound && sitemapContent) {
                    score.value += 3;
                    score.details.push('XML sitemap found');
                    score.checks.push({ name: 'XML sitemap', status: 'pass' });
                    
                    // Check for lastmod dates
                    if (sitemapContent.includes('<lastmod>') || sitemapContent.includes('lastmod')) {
                        score.value += 2;
                        score.details.push('Sitemap includes update dates');
                        score.checks.push({ name: 'Lastmod dates', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Lastmod dates', status: 'fail' });
                    }
                } else {
                    score.checks.push({ name: 'XML sitemap', status: 'fail' });
                    score.checks.push({ name: 'Lastmod dates', status: 'fail' });
                }
                
                // Check for RSS/Atom feed
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    const feedLinks = [
                        doc.querySelector('link[type="application/rss+xml"]'),
                        doc.querySelector('link[type="application/atom+xml"]'),
                        doc.querySelector('link[type="application/feed+json"]'),
                        doc.querySelector('a[href*="/feed"]'),
                        doc.querySelector('a[href*="/rss"]'),
                        doc.querySelector('a[href*=".rss"]'),
                        doc.querySelector('a[href*="/atom"]')
                    ];
                    
                    if (feedLinks.some(link => link)) {
                        score.value += 3;
                        score.details.push('RSS/Atom feed available');
                        score.checks.push({ name: 'RSS/JSON feed', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'RSS/JSON feed', status: 'fail' });
                    }
                    
                    // Check for recent content indicators
                    const currentYear = new Date().getFullYear();
                    const recentYears = [currentYear, currentYear - 1];
                    
                    const hasRecentContent = recentYears.some(year => 
                        htmlContent.includes(year.toString())
                    );
                    
                    if (hasRecentContent) {
                        score.value += 2;
                        score.details.push('Recent content found');
                        score.checks.push({ name: 'Recent content', status: 'pass' });
                        
                        // Check for specific months for extra freshness
                        const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                                      'July', 'August', 'September', 'October', 'November', 'December'];
                        const currentMonth = new Date().getMonth();
                        const recentMonths = months.slice(Math.max(0, currentMonth - 2), currentMonth + 1);
                        
                        if (recentMonths.some(month => htmlContent.includes(month))) {
                            score.debug.push('Very recent content (within 3 months)');
                        }
                    } else {
                        score.checks.push({ name: 'Recent content', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check freshness signals');
            }
            
            return score;
        }

        async function checkTechnical(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for semantic HTML5 elements
                    const semanticElements = {
                        article: doc.querySelectorAll('article').length,
                        header: doc.querySelectorAll('header').length,
                        footer: doc.querySelectorAll('footer').length,
                        main: doc.querySelectorAll('main').length,
                        section: doc.querySelectorAll('section').length,
                        nav: doc.querySelectorAll('nav').length,
                        aside: doc.querySelectorAll('aside').length
                    };
                    
                    const semanticScore = Object.values(semanticElements).filter(count => count > 0).length;
                    
                    if (semanticScore >= 4) {
                        score.value += 4;
                        score.details.push('Excellent HTML5 structure');
                        score.checks.push({ name: 'HTML5 structure', status: 'pass' });
                    } else if (semanticScore >= 2) {
                        score.value += 2;
                        score.details.push('Basic HTML5 structure');
                        score.checks.push({ name: 'HTML5 structure', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'HTML5 structure', status: 'fail' });
                    }
                    
                    score.debug.push(`Semantic elements: ${JSON.stringify(semanticElements)}`);
                    
                    // Check for alt text on images
                    const images = doc.querySelectorAll('img');
                    const imagesWithAlt = doc.querySelectorAll('img[alt]');
                    const imagesWithGoodAlt = Array.from(imagesWithAlt).filter(img => {
                        const alt = img.getAttribute('alt');
                        return alt && alt.trim().length > 3 && !alt.toLowerCase().includes('image');
                    });
                    
                    if (images.length > 0) {
                        const altCoverage = imagesWithAlt.length / images.length;
                        const goodAltCoverage = imagesWithGoodAlt.length / images.length;
                        
                        if (goodAltCoverage > 0.7) {
                            score.value += 3;
                            score.details.push('Excellent alt text coverage');
                            score.checks.push({ name: 'Image alt text', status: 'pass' });
                        } else if (altCoverage > 0.5) {
                            score.value += 1;
                            score.details.push('Partial alt text coverage');
                            score.checks.push({ name: 'Image alt text', status: 'partial' });
                        } else {
                            score.checks.push({ name: 'Image alt text', status: 'fail' });
                        }
                        
                        score.debug.push(`Images: ${images.length} total, ${imagesWithAlt.length} with alt, ${imagesWithGoodAlt.length} with good alt`);
                    } else {
                        // No images, so not penalized
                        score.value += 1;
                        score.details.push('No images to check');
                        score.checks.push({ name: 'Image alt text', status: 'pass' });
                    }
                    
                    // Check mobile viewport and responsive design
                    const viewport = doc.querySelector('meta[name="viewport"]');
                    const hasResponsiveImages = doc.querySelector('img[srcset], picture');
                    const hasMediaQueries = htmlContent.includes('@media');
                    
                    if (viewport) {
                        score.value += 3;
                        score.details.push('Mobile-optimized');
                        score.checks.push({ name: 'Mobile ready', status: 'pass' });
                        
                        if (hasResponsiveImages || hasMediaQueries) {
                            score.debug.push('Advanced responsive features detected');
                        }
                    } else {
                        score.checks.push({ name: 'Mobile ready', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check technical signals');
            }
            
            return score;
        }

        async function checkContentFormat(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Enhanced FAQ detection
                    const faqSignals = [
                        htmlContent.toLowerCase().includes('frequently asked'),
                        htmlContent.toLowerCase().includes('faq'),
                        htmlContent.includes('"@type":"FAQPage"'),
                        htmlContent.includes('"@type":"Question"'),
                        doc.querySelector('.faq, #faq, [class*="faq"], [id*="faq"]'),
                        doc.querySelector('dl'), // Definition lists often used for FAQs
                        Array.from(doc.querySelectorAll('h2, h3, h4')).some(h => 
                            h.textContent.toLowerCase().includes('?')
                        )
                    ];
                    
                    if (faqSignals.filter(signal => signal).length >= 2) {
                        score.value += 3;
                        score.details.push('FAQ/Q&A content found');
                        score.checks.push({ name: 'FAQ content', status: 'pass' });
                    } else if (faqSignals.some(signal => signal)) {
                        score.value += 1;
                        score.checks.push({ name: 'FAQ content', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'FAQ content', status: 'fail' });
                    }
                    
                    // Check for lists and tables
                    const lists = doc.querySelectorAll('ul, ol');
                    const tables = doc.querySelectorAll('table');
                    const definitionLists = doc.querySelectorAll('dl');
                    
                    const structuredContent = lists.length + tables.length + definitionLists.length;
                    
                    if (structuredContent > 5) {
                        score.value += 3;
                        score.details.push(`Rich structured content (${structuredContent} elements)`);
                        score.checks.push({ name: 'Lists/Tables', status: 'pass' });
                    } else if (structuredContent > 2) {
                        score.value += 1;
                        score.checks.push({ name: 'Lists/Tables', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Lists/Tables', status: 'fail' });
                    }
                    
                    score.debug.push(`Structured content: ${lists.length} lists, ${tables.length} tables, ${definitionLists.length} dl`);
                    
                    // Check for definitions or glossary
                    const definitionSignals = [
                        doc.querySelector('dl'),
                        doc.querySelector('[class*="glossary"], [id*="glossary"]'),
                        doc.querySelector('[class*="definition"], [id*="definition"]'),
                        doc.querySelector('[class*="dictionary"], [id*="dictionary"]'),
                        htmlContent.toLowerCase().includes('definition'),
                        htmlContent.toLowerCase().includes('glossary'),
                        htmlContent.toLowerCase().includes('means that'),
                        htmlContent.toLowerCase().includes('refers to')
                    ];
                    
                    if (definitionSignals.filter(signal => signal).length >= 2) {
                        score.value += 2;
                        score.details.push('Definitions/glossary present');
                        score.checks.push({ name: 'Definitions', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Definitions', status: 'fail' });
                    }
                    
                    // Check content depth
                    const textContent = doc.body ? doc.body.textContent : '';
                    const words = textContent.split(/\s+/).filter(word => word.length > 2);
                    const wordCount = words.length;
                    
                    if (wordCount > 1000) {
                        score.value += 2;
                        score.details.push(`Comprehensive content (${wordCount}+ words)`);
                        score.checks.push({ name: 'Content depth', status: 'pass' });
                    } else if (wordCount > 500) {
                        score.value += 1;
                        score.details.push(`Moderate content (${wordCount} words)`);
                        score.checks.push({ name: 'Content depth', status: 'partial' });
                    } else {
                        score.details.push(`Thin content (${wordCount} words)`);
                        score.checks.push({ name: 'Content depth', status: 'fail' });
                    }
                    
                    score.debug.push(`Word count: ${wordCount}`);
                }
            } catch (error) {
                score.details.push('Unable to check content formats');
            }
            
            return score;
        }

        async function checkLicensing(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [], debug: [] };
            
            try {
                // Check robots.txt for differentiation
                const robotsUrl = `${baseUrl}/robots.txt`;
                const robotsContent = await fetchWithCORS(robotsUrl);
                
                if (robotsContent) {
                    // Check for training vs retrieval bot differentiation
                    const bots = {
                        training: ['GPTBot', 'CCBot', 'ChatGPT-User', 'Claude-Web'],
                        search: ['OAI-SearchBot', 'ChatGPT-User', 'PerplexityBot', 'YouBot']
                    };
                    
                    const hasTrainingBots = bots.training.some(bot => 
                        robotsContent.includes(bot)
                    );
                    const hasSearchBots = bots.search.some(bot => 
                        robotsContent.includes(bot)
                    );
                    
                    if (hasTrainingBots && hasSearchBots) {
                        score.value += 4;
                        score.details.push('Differentiates bot types');
                        score.checks.push({ name: 'Bot differentiation', status: 'pass' });
                    } else if (hasTrainingBots || hasSearchBots) {
                        score.value += 2;
                        score.details.push('Some bot differentiation');
                        score.checks.push({ name: 'Bot differentiation', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Bot differentiation', status: 'fail' });
                    }
                    
                    // Check for llms.txt
                    if (robotsContent.toLowerCase().includes('llms.txt')) {
                        score.value += 3;
                        score.details.push('llms.txt configured');
                        score.checks.push({ name: 'llms.txt policy', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'llms.txt policy', status: 'fail' });
                    }
                }
                
                // Check for terms/license page
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const licenseSignals = [
                        htmlContent.toLowerCase().includes('terms of service'),
                        htmlContent.toLowerCase().includes('terms of use'),
                        htmlContent.toLowerCase().includes('terms and conditions'),
                        htmlContent.toLowerCase().includes('license'),
                        htmlContent.toLowerCase().includes('copyright'),
                        htmlContent.toLowerCase().includes('creative commons'),
                        htmlContent.toLowerCase().includes('privacy policy'),
                        htmlContent.includes('Â©'),
                        htmlContent.includes('&copy;')
                    ];
                    
                    const licenseCount = licenseSignals.filter(signal => signal).length;
                    
                    if (licenseCount >= 3) {
                        score.value += 3;
                        score.details.push('Strong license/terms presence');
                        score.checks.push({ name: 'Terms/License', status: 'pass' });
                    } else if (licenseCount >= 1) {
                        score.value += 1;
                        score.details.push('Basic license/terms present');
                        score.checks.push({ name: 'Terms/License', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Terms/License', status: 'fail' });
                    }
                    
                    score.debug.push(`License signals: ${licenseCount}`);
                }
            } catch (error) {
                score.details.push('Unable to check licensing');
            }
            
            return score;
        }

        function updateProgress(percent, message) {
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = percent + '%';
            progressBar.textContent = percent + '%';
            
            const loadingSection = document.getElementById('loadingSection');
            const statusText = loadingSection.querySelector('p');
            statusText.textContent = message;
        }

        function calculateTotalScore() {
            let total = 0;
            for (const factor in analysisResults.factors) {
                total += analysisResults.factors[factor].value;
            }
            analysisResults.totalScore = Math.round(total);
        }

        function displayResults() {
            const resultsSection = document.getElementById('resultsSection');
            
            // Display total score with animation
            animateScore(analysisResults.totalScore);
            
            // Display factor cards
            displayFactors();
            
            // Generate ALL recommendations
            generateAllRecommendations();
            
            // Show results
            resultsSection.classList.add('active');
        }

        function animateScore(targetScore) {
            const scoreElement = document.getElementById('totalScore');
            const scoreCircle = document.getElementById('scoreCircle');
            const scoreStatus = document.getElementById('scoreStatus');
            
            // Animate number
            let currentScore = 0;
            const increment = targetScore / 50;
            const timer = setInterval(() => {
                currentScore += increment;
                if (currentScore >= targetScore) {
                    currentScore = targetScore;
                    clearInterval(timer);
                }
                scoreElement.textContent = Math.round(currentScore);
            }, 20);
            
            // Animate circle (adjusted for max score of 80)
            const circumference = 2 * Math.PI * 90;
            const offset = circumference - (targetScore / 80) * circumference;
            scoreCircle.style.strokeDashoffset = offset;
            
            // Set status message
            if (targetScore >= 70) {
                scoreStatus.textContent = 'Excellent LLM Visibility';
                scoreStatus.style.color = '#4caf50';
            } else if (targetScore >= 50) {
                scoreStatus.textContent = 'Good LLM Visibility';
                scoreStatus.style.color = '#4caf50';
            } else if (targetScore >= 35) {
                scoreStatus.textContent = 'Moderate LLM Visibility';
                scoreStatus.style.color = '#ff9800';
            } else {
                scoreStatus.textContent = 'Needs Improvement';
                scoreStatus.style.color = '#f44336';
            }
        }

        function displayFactors() {
            const factorsGrid = document.getElementById('factorsGrid');
            factorsGrid.innerHTML = '';
            
            const factorNames = {
                botAccessibility: 'Bot Accessibility',
                parsability: 'Parsability & Structure',
                citationFriendliness: 'Citation Friendliness',
                authority: 'Authority & Trust',
                freshness: 'Freshness & Feeds',
                technical: 'Technical Signals',
                contentFormat: 'Content Format',
                licensing: 'Licensing Readiness'
            };
            
            for (const [key, factor] of Object.entries(analysisResults.factors)) {
                const card = createFactorCard(factorNames[key], factor);
                factorsGrid.appendChild(card);
            }
        }

        function createFactorCard(name, factor) {
            const card = document.createElement('div');
            card.className = 'factor-card';
            
            const scoreColor = factor.value >= 8 ? '#4caf50' : 
                             factor.value >= 5 ? '#ff9800' : '#f44336';
            
            // Include debug info if available
            const debugInfo = factor.debug && factor.debug.length > 0 
                ? `<div class="debug-info">Debug: ${factor.debug.join(' | ')}</div>` 
                : '';
            
            card.innerHTML = `
                <div class="factor-header">
                    <div class="factor-title">${name}</div>
                    <div class="factor-score" style="color: ${scoreColor}">${factor.value}/${factor.max}</div>
                </div>
                <div class="factor-details">${factor.details.join(', ') || 'No details available'}</div>
                <ul class="factor-items">
                    ${factor.checks.map(check => `
                        <li>
                            <span class="check-icon ${check.status}">
                                ${check.status === 'pass' ? 'âœ“' : check.status === 'partial' ? '~' : 'âœ—'}
                            </span>
                            ${check.name}
                        </li>
                    `).join('')}
                </ul>
                ${debugInfo}
            `;
            
            return card;
        }

        function generateAllRecommendations() {
            const recommendations = document.getElementById('recommendations');
            
            const factorInfo = {
                botAccessibility: {
                    name: 'Bot Accessibility',
                    explanation: 'AI assistants need permission to access and read your website. Without proper bot access, ChatGPT, Claude, and other AI tools cannot discover or reference your content.',
                    whyImportant: 'If AI bots cannot access your site, your content will never appear in AI-generated responses, missing a growing source of traffic and visibility.'
                },
                parsability: {
                    name: 'Parsability & Structure',
                    explanation: 'AI systems need clear, semantic HTML structure to understand your content hierarchy and meaning. This includes proper headings, schema markup, and semantic HTML5 tags.',
                    whyImportant: 'Well-structured content helps AI understand what your page is about, making it more likely to be cited accurately in relevant queries.'
                },
                citationFriendliness: {
                    name: 'Citation Friendliness',
                    explanation: 'AI systems prefer content they can easily quote and attribute. This includes clear authorship, dates, and bite-sized information chunks.',
                    whyImportant: 'Citation-friendly content is more likely to be quoted verbatim in AI responses, with proper attribution driving traffic back to your site.'
                },
                authority: {
                    name: 'Authority & Trust',
                    explanation: 'AI systems evaluate trustworthiness through signals like SSL certificates, contact information, about pages, and social proof.',
                    whyImportant: 'AI prioritizes authoritative sources to ensure accuracy. Higher trust signals mean your content is more likely to be selected over competitors.'
                },
                freshness: {
                    name: 'Freshness & Feeds',
                    explanation: 'AI systems need to know when content was published and updated. Sitemaps, RSS feeds, and date stamps help AI identify current information.',
                    whyImportant: 'For time-sensitive queries, AI will prefer sources with clear recency signals. Outdated-looking content gets ignored.'
                },
                technical: {
                    name: 'Technical Signals',
                    explanation: 'Technical optimization ensures AI can efficiently process your site. This includes semantic HTML5, proper alt text, and mobile optimization.',
                    whyImportant: 'Technical issues can prevent AI from properly parsing your content, even if the information is valuable.'
                },
                contentFormat: {
                    name: 'Content Format & Coverage',
                    explanation: 'AI systems prefer certain content formats like FAQs, lists, tables, and comprehensive coverage of topics.',
                    whyImportant: 'Well-formatted content is easier for AI to extract and present to users. FAQ sections are particularly valuable for question-based queries.'
                },
                licensing: {
                    name: 'Licensing & Policy Readiness',
                    explanation: 'Clear licensing and bot policies tell AI systems how they can use your content. This includes robots.txt differentiation and terms of service.',
                    whyImportant: 'As AI companies establish content partnerships, sites with clear licensing policies will have advantages in visibility and potential revenue.'
                }
            };
            
            // Build comprehensive recommendations HTML
            let html = '<h2>ðŸ“‹ Complete Analysis & Recommendations</h2>';
            
            // Add all factors with their recommendations
            for (const [key, factor] of Object.entries(analysisResults.factors)) {
                const info = factorInfo[key];
                const score = factor.value;
                const maxScore = factor.max;
                const percentage = Math.round((score / maxScore) * 100);
                
                // Determine priority
                let priority = 'low';
                let priorityText = 'Low Priority';
                if (percentage < 40) {
                    priority = 'high';
                    priorityText = 'High Priority - Fix Soon';
                } else if (percentage < 70) {
                    priority = 'medium';
                    priorityText = 'Medium Priority';
                }
                
                // Get specific recommendations for this factor
                const rec = getRecommendation(key, factor);
                
                html += `
                    <div class="factor-section">
                        <h3>
                            ${info.name}
                            <span style="font-size: 1rem; color: ${percentage >= 70 ? '#4caf50' : percentage >= 40 ? '#ff9800' : '#f44336'}">
                                ${score}/${maxScore} (${percentage}%)
                            </span>
                        </h3>
                        
                        <div class="factor-explanation">
                            <strong>What this measures:</strong> ${info.explanation}
                            <br><br>
                            <strong>Why it matters:</strong> ${info.whyImportant}
                        </div>
                        
                        <div class="recommendation-item">
                            <span class="recommendation-priority priority-${priority}">${priorityText}</span>
                            <div class="recommendation-title">${rec.title}</div>
                            <p>${rec.description}</p>
                            <ol class="recommendation-steps">
                                ${rec.steps.map(step => `<li>${step}</li>`).join('')}
                            </ol>
                        </div>
                    </div>
                `;
            }
            
            recommendations.innerHTML = html;
        }

        function getRecommendation(factorKey, factor) {
            const recommendations = {
                botAccessibility: {
                    title: 'Optimize Bot Accessibility',
                    description: 'Ensure AI bots can discover and access your content.',
                    steps: [
                        'Create or update your robots.txt file in the root directory',
                        'Add specific allow rules for AI bots: GPTBot, ClaudeBot, ChatGPT-User, OAI-SearchBot, PerplexityBot',
                        'Create an llms.txt file highlighting your best content for AI systems',
                        'Consider differentiating between training bots (GPTBot) and retrieval bots (OAI-SearchBot)',
                        'Test your robots.txt at Google\'s robots.txt tester',
                        'Monitor server logs to verify AI bots are visiting your site'
                    ]
                },
                parsability: {
                    title: 'Improve Content Structure',
                    description: 'Make your content easily understandable for AI parsers.',
                    steps: [
                        'Add one clear H1 tag per page describing the main topic',
                        'Create logical heading hierarchy (H1 â†’ H2 â†’ H3) for content sections',
                        'Implement Schema.org JSON-LD markup for your content type',
                        'Use semantic HTML5 tags: <article>, <main>, <section>, <nav>, <aside>',
                        'Add structured data for articles, FAQs, or products as appropriate',
                        'Validate your schema markup using Google\'s Rich Results Test',
                        'Ensure your HTML validates at validator.w3.org'
                    ]
                },
                citationFriendliness: {
                    title: 'Enhance Citation Potential',
                    description: 'Make your content easy for AI to quote and attribute.',
                    steps: [
                        'Add author meta tags: <meta name="author" content="Name">',
                        'Include publication and update dates in both visible text and meta tags',
                        'Break content into concise 40-120 word paragraphs with clear points',
                        'Add bylines with author credentials and expertise',
                        'Include both internal links (to related content) and external citations',
                        'Use <time> tags for dates with datetime attributes',
                        'Add Schema.org Article markup with author and date information'
                    ]
                },
                authority: {
                    title: 'Build Trust Signals',
                    description: 'Establish your site as a trustworthy source for AI systems.',
                    steps: [
                        'Create comprehensive About and Team pages with credentials',
                        'Add clear Contact page with multiple contact methods',
                        'Ensure HTTPS is enabled across your entire site',
                        'Display testimonials, reviews, or case studies prominently',
                        'List partnerships, certifications, or awards',
                        'Add author bio boxes to content with expertise indicators',
                        'Include privacy policy and terms of service pages',
                        'Register with Google Business Profile if applicable'
                    ]
                },
                freshness: {
                    title: 'Signal Content Freshness',
                    description: 'Help AI systems identify your most current content.',
                    steps: [
                        'Create and submit XML sitemap with <lastmod> dates',
                        'Implement RSS or Atom feed for new content',
                        'Display "Published" and "Last Updated" dates visibly on pages',
                        'Use Schema.org datePublished and dateModified properties',
                        'Update content regularly with current information',
                        'Include current year in footers and relevant content',
                        'Submit sitemap to Google Search Console and Bing Webmaster Tools',
                        'Consider implementing a "Recent Updates" section'
                    ]
                },
                technical: {
                    title: 'Optimize Technical Implementation',
                    description: 'Ensure technical excellence for AI processing.',
                    steps: [
                        'Implement semantic HTML5 structure: <header>, <main>, <footer>, <article>',
                        'Add descriptive alt text to all images (not just "image")',
                        'Include viewport meta tag for mobile optimization',
                        'Use responsive images with srcset attributes',
                        'Implement structured data breadcrumbs for navigation',
                        'Ensure proper heading hierarchy without skipping levels',
                        'Minimize JavaScript-rendered content for better crawlability',
                        'Test mobile-friendliness with Google\'s Mobile-Friendly Test'
                    ]
                },
                contentFormat: {
                    title: 'Optimize Content Formats',
                    description: 'Use AI-preferred content structures and formats.',
                    steps: [
                        'Create FAQ sections with clear question-answer format',
                        'Use lists and bullet points for easy scanning',
                        'Add comparison tables for products or features',
                        'Include definitions and glossaries for technical terms',
                        'Aim for comprehensive coverage (1000+ words) on main topics',
                        'Structure how-to content with numbered steps',
                        'Add table of contents for long articles',
                        'Use Schema.org FAQPage markup for Q&A content'
                    ]
                },
                licensing: {
                    title: 'Establish AI Content Policies',
                    description: 'Prepare for the AI content ecosystem.',
                    steps: [
                        'Differentiate between training and retrieval bots in robots.txt',
                        'Create llms.txt file with content guidelines and highlights',
                        'Add AI usage terms to your terms of service',
                        'Consider copyright and licensing statements for your content',
                        'Research AI publisher programs (OpenAI, Perplexity, etc.)',
                        'Add specific bot rules: Allow for search bots, consider blocking for training',
                        'Include content licensing information in meta tags',
                        'Monitor announcements about AI content partnerships'
                    ]
                }
            };
            
            return recommendations[factorKey] || {
                title: 'General Improvement',
                description: 'This area needs attention.',
                steps: ['Review best practices', 'Implement improvements', 'Test changes', 'Monitor results']
            };
        }

        function showError(message) {
            document.getElementById('errorSection').style.display = 'block';
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('loadingSection').style.display = 'none';
        }

        // Allow Enter key to trigger analysis
        document.getElementById('domainInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                analyzeDomain();
            }
        });
    </script>
</body>
</html>
