<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Visibility Diagnosis Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.95;
        }

        .input-section {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .input-group {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        input[type="text"] {
            flex: 1;
            padding: 15px 20px;
            font-size: 1.1rem;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            transition: all 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
        }

        .analyze-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102,126,234,0.3);
        }

        .analyze-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-section {
            display: none;
        }

        .results-section.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .overall-score {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .score-circle {
            width: 200px;
            height: 200px;
            margin: 0 auto 20px;
            position: relative;
        }

        .score-circle svg {
            transform: rotate(-90deg);
        }

        .score-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #333;
        }

        .score-label {
            font-size: 1.3rem;
            color: #666;
            margin-bottom: 10px;
        }

        .score-status {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 10px;
        }

        .factors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .factor-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            transition: all 0.3s;
        }

        .factor-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.12);
        }

        .factor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .factor-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
        }

        .factor-score {
            font-size: 1.3rem;
            font-weight: bold;
            padding: 5px 15px;
            border-radius: 20px;
            background: #f5f5f5;
        }

        .factor-details {
            color: #666;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .factor-items {
            list-style: none;
        }

        .factor-items li {
            padding: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .check-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }

        .check-icon.pass {
            background: #4caf50;
        }

        .check-icon.fail {
            background: #f44336;
        }

        .check-icon.partial {
            background: #ff9800;
        }

        .recommendations {
            background: white;
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .recommendations h2 {
            color: #333;
            margin-bottom: 25px;
            font-size: 1.8rem;
        }

        .recommendation-item {
            background: linear-gradient(135deg, #667eea10, #764ba210);
            border-left: 4px solid #667eea;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
        }

        .recommendation-priority {
            display: inline-block;
            padding: 5px 15px;
            background: #667eea;
            color: white;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .recommendation-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .recommendation-steps {
            margin-top: 15px;
            padding-left: 20px;
        }

        .recommendation-steps li {
            margin-bottom: 8px;
            color: #666;
            line-height: 1.6;
        }

        .loading {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 20px;
            margin-bottom: 30px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #c62828;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #f5f5f5;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 15px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ¤– LLM Visibility Diagnosis Tool</h1>
            <p>Analyze how well AI assistants can discover, understand, and cite your website</p>
            <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 5px;">8 Real Factors â€¢ 100% Verified Analysis â€¢ No Estimates</p>
        </div>

        <div class="input-section">
            <div class="input-group">
                <input type="text" id="domainInput" placeholder="Enter domain (e.g., example.com)" />
                <button class="analyze-btn" onclick="analyzeDomain()">Analyze Website</button>
            </div>
        </div>

        <div id="loadingSection" class="loading" style="display: none;">
            <div class="spinner"></div>
            <p>Analyzing website visibility for AI assistants...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%">0%</div>
            </div>
        </div>

        <div id="errorSection" style="display: none;">
            <div class="error-message" id="errorMessage"></div>
        </div>

        <div id="resultsSection" class="results-section">
            <div class="overall-score">
                <div class="score-circle">
                    <svg width="200" height="200">
                        <circle cx="100" cy="100" r="90" stroke="#e0e0e0" stroke-width="20" fill="none"/>
                        <circle id="scoreCircle" cx="100" cy="100" r="90" stroke="url(#gradient)" stroke-width="20" fill="none" 
                                stroke-dasharray="565" stroke-dashoffset="565" stroke-linecap="round"/>
                        <defs>
                            <linearGradient id="gradient">
                                <stop offset="0%" stop-color="#667eea"/>
                                <stop offset="100%" stop-color="#764ba2"/>
                            </linearGradient>
                        </defs>
                    </svg>
                    <div class="score-number" id="totalScore">0</div>
                </div>
                <div class="score-label">LLM Visibility Score</div>
                <div class="score-status" id="scoreStatus">Calculating...</div>
            </div>

            <div class="factors-grid" id="factorsGrid"></div>

            <div class="recommendations" id="recommendations"></div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION - YOUR VERCEL URL IS HERE! =====
        const PROXY_BASE_URL = 'https://llm-visibility-tool-chi.vercel.app/api/analyze';
        
        // Configuration for bot checking
        const AI_BOTS = ['GPTBot', 'OAI-SearchBot', 'ClaudeBot', 'PerplexityBot', 'ChatGPT-User', 'CCBot', 'Amazonbot', 'Applebot'];
        
        let analysisResults = {};

        async function analyzeDomain() {
            const domainInput = document.getElementById('domainInput');
            const domain = domainInput.value.trim().replace(/^https?:\/\//, '').replace(/\/$/, '');
            
            if (!domain) {
                showError('Please enter a valid domain');
                return;
            }

            // Reset and show loading
            document.getElementById('resultsSection').classList.remove('active');
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('loadingSection').style.display = 'block';
            
            try {
                await performAnalysis(domain);
            } catch (error) {
                showError(`Analysis failed: ${error.message}. Please ensure the domain is accessible and try again.`);
            } finally {
                document.getElementById('loadingSection').style.display = 'none';
            }
        }

        async function performAnalysis(domain) {
            analysisResults = {
                domain: domain,
                factors: {},
                totalScore: 0
            };

            const baseUrl = `https://${domain}`;
            
            // Update progress
            updateProgress(10, 'Checking bot accessibility...');
            analysisResults.factors.botAccessibility = await checkBotAccessibility(baseUrl);
            
            updateProgress(20, 'Analyzing content structure...');
            analysisResults.factors.parsability = await checkParsability(baseUrl);
            
            updateProgress(30, 'Evaluating citation friendliness...');
            analysisResults.factors.citationFriendliness = await checkCitationFriendliness(baseUrl);
            
            updateProgress(40, 'Assessing authority signals...');
            analysisResults.factors.authority = await checkAuthority(baseUrl);
            
            updateProgress(50, 'Checking content freshness...');
            analysisResults.factors.freshness = await checkFreshness(baseUrl);
            
            updateProgress(60, 'Analyzing technical signals...');
            analysisResults.factors.technical = await checkTechnical(baseUrl);
            
            updateProgress(70, 'Reviewing content formats...');
            analysisResults.factors.contentFormat = await checkContentFormat(baseUrl);
            
            updateProgress(80, 'Checking licensing readiness...');
            analysisResults.factors.licensing = await checkLicensing(baseUrl);
            
            updateProgress(90, 'Analyzing citation presence...');
            analysisResults.factors.citationMonitoring = checkCitationMonitoring();
            
            updateProgress(95, 'Evaluating competitive position...');
            analysisResults.factors.competitive = checkCompetitive();
            
            updateProgress(100, 'Generating report...');
            
            // Calculate total score
            calculateTotalScore();
            
            // Display results
            displayResults();
        }

        async function fetchWithCORS(url, type = 'html') {
            try {
                // Extract domain from URL if it's a full URL
                let domain = url.replace(/^https?:\/\//, '').replace(/\/$/, '');
                
                // For specific resources, extract just the domain
                if (url.includes('/robots.txt')) {
                    domain = new URL(url).hostname;
                    type = 'robots';
                } else if (url.includes('/sitemap.xml')) {
                    domain = new URL(url).hostname;
                    type = 'sitemap';
                } else if (url.includes('/llms.txt')) {
                    domain = new URL(url).hostname;
                    type = 'llms';
                }
                
                // Call your Vercel proxy
                const proxyUrl = `${PROXY_BASE_URL}?url=${encodeURIComponent(domain)}&type=${type}`;
                console.log('Fetching via proxy:', proxyUrl);
                
                const response = await fetch(proxyUrl);
                const data = await response.json();
                
                if (data.success) {
                    return data.content;
                } else {
                    console.error('Proxy error:', data.error);
                    return null;
                }
            } catch (error) {
                console.error('Fetch error:', error);
                return null;
            }
        }

        async function checkBotAccessibility(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                // Check robots.txt
                const robotsUrl = `${baseUrl}/robots.txt`;
                const robotsContent = await fetchWithCORS(robotsUrl);
                
                if (robotsContent) {
                    score.details.push('robots.txt found');
                    score.checks.push({ name: 'robots.txt exists', status: 'pass' });
                    score.value += 3;
                    
                    // Check for AI bot allowances
                    const allowedBots = AI_BOTS.filter(bot => 
                        !robotsContent.includes(`User-agent: ${bot}\nDisallow: /`)
                    );
                    
                    if (allowedBots.length > 0) {
                        score.value += Math.min(4, allowedBots.length);
                        score.details.push(`${allowedBots.length} AI bots allowed`);
                        score.checks.push({ name: 'AI bots allowed', status: allowedBots.length > 2 ? 'pass' : 'partial' });
                    } else {
                        score.checks.push({ name: 'AI bots allowed', status: 'fail' });
                    }
                    
                    // Check for llms.txt
                    if (robotsContent.includes('llms.txt')) {
                        score.value += 2;
                        score.details.push('llms.txt reference found');
                        score.checks.push({ name: 'llms.txt configured', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'llms.txt configured', status: 'fail' });
                    }
                } else {
                    score.checks.push({ name: 'robots.txt exists', status: 'fail' });
                    score.checks.push({ name: 'AI bots allowed', status: 'fail' });
                    score.checks.push({ name: 'llms.txt configured', status: 'fail' });
                }
                
                // Check for llms.txt directly
                try {
                    const llmsUrl = `${baseUrl}/llms.txt`;
                    const llmsContent = await fetchWithCORS(llmsUrl);
                    if (llmsContent) {
                        score.value += 1;
                        score.details.push('llms.txt file exists');
                    }
                } catch (e) {
                    // llms.txt not found
                }
                
            } catch (error) {
                score.details.push('Unable to check bot accessibility');
            }
            
            return score;
        }

        async function checkParsability(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for proper heading structure
                    const h1Count = doc.querySelectorAll('h1').length;
                    const h2Count = doc.querySelectorAll('h2').length;
                    const h3Count = doc.querySelectorAll('h3').length;
                    
                    if (h1Count > 0) {
                        score.value += 2;
                        score.details.push('H1 tags found');
                        score.checks.push({ name: 'H1 headings present', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'H1 headings present', status: 'fail' });
                    }
                    
                    if (h2Count > 0 && h3Count > 0) {
                        score.value += 3;
                        score.details.push('Hierarchical heading structure');
                        score.checks.push({ name: 'H2-H3 hierarchy', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'H2-H3 hierarchy', status: h2Count > 0 ? 'partial' : 'fail' });
                    }
                    
                    // Check for schema markup
                    const schemaScripts = doc.querySelectorAll('script[type="application/ld+json"]');
                    if (schemaScripts.length > 0) {
                        score.value += 3;
                        score.details.push('Schema.org markup found');
                        score.checks.push({ name: 'Schema.org markup', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Schema.org markup', status: 'fail' });
                    }
                    
                    // Check for semantic HTML
                    const hasArticle = doc.querySelector('article') !== null;
                    const hasMain = doc.querySelector('main') !== null;
                    const hasNav = doc.querySelector('nav') !== null;
                    
                    if (hasArticle || hasMain) {
                        score.value += 2;
                        score.details.push('Semantic HTML structure');
                        score.checks.push({ name: 'Semantic HTML tags', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Semantic HTML tags', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to analyze page structure');
            }
            
            return score;
        }

        async function checkCitationFriendliness(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for author information
                    const authorMeta = doc.querySelector('meta[name="author"]');
                    const authorSchema = htmlContent.includes('"@type":"Person"') || htmlContent.includes('"author"');
                    
                    if (authorMeta || authorSchema) {
                        score.value += 3;
                        score.details.push('Author information present');
                        score.checks.push({ name: 'Author attribution', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Author attribution', status: 'fail' });
                    }
                    
                    // Check for dates
                    const dateMeta = doc.querySelector('meta[property="article:published_time"], meta[name="publish_date"], time');
                    if (dateMeta) {
                        score.value += 2;
                        score.details.push('Publication dates found');
                        score.checks.push({ name: 'Date information', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Date information', status: 'fail' });
                    }
                    
                    // Check for structured paragraphs
                    const paragraphs = doc.querySelectorAll('p');
                    let wellStructured = 0;
                    paragraphs.forEach(p => {
                        const text = p.textContent.trim();
                        if (text.length > 40 && text.length < 200) {
                            wellStructured++;
                        }
                    });
                    
                    if (wellStructured > 5) {
                        score.value += 3;
                        score.details.push('Well-structured paragraphs');
                        score.checks.push({ name: 'Concise paragraphs', status: 'pass' });
                    } else if (wellStructured > 2) {
                        score.value += 1;
                        score.checks.push({ name: 'Concise paragraphs', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Concise paragraphs', status: 'fail' });
                    }
                    
                    // Check for internal/external links
                    const links = doc.querySelectorAll('a[href]');
                    if (links.length > 10) {
                        score.value += 2;
                        score.details.push('Good link structure');
                        score.checks.push({ name: 'Link citations', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Link citations', status: links.length > 5 ? 'partial' : 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check citation structure');
            }
            
            return score;
        }

        async function checkAuthority(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for About page
                    const aboutLink = doc.querySelector('a[href*="about"], a[href*="About"]');
                    if (aboutLink) {
                        score.value += 3;
                        score.details.push('About page found');
                        score.checks.push({ name: 'About page', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'About page', status: 'fail' });
                    }
                    
                    // Check for Contact page
                    const contactLink = doc.querySelector('a[href*="contact"], a[href*="Contact"]');
                    if (contactLink) {
                        score.value += 3;
                        score.details.push('Contact page found');
                        score.checks.push({ name: 'Contact page', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Contact page', status: 'fail' });
                    }
                    
                    // Check for social proof / trust signals
                    const trustSignals = htmlContent.includes('testimonial') || 
                                       htmlContent.includes('review') || 
                                       htmlContent.includes('trusted by') ||
                                       htmlContent.includes('partner');
                    
                    if (trustSignals) {
                        score.value += 2;
                        score.details.push('Trust signals present');
                        score.checks.push({ name: 'Trust indicators', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Trust indicators', status: 'fail' });
                    }
                    
                    // Check for SSL
                    if (baseUrl.startsWith('https')) {
                        score.value += 2;
                        score.details.push('SSL certificate active');
                        score.checks.push({ name: 'SSL/HTTPS', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'SSL/HTTPS', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check authority signals');
            }
            
            return score;
        }

        async function checkFreshness(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                // Check for sitemap
                const sitemapUrl = `${baseUrl}/sitemap.xml`;
                const sitemapContent = await fetchWithCORS(sitemapUrl);
                
                if (sitemapContent) {
                    score.value += 3;
                    score.details.push('XML sitemap found');
                    score.checks.push({ name: 'XML sitemap', status: 'pass' });
                    
                    // Check for lastmod dates
                    if (sitemapContent.includes('<lastmod>')) {
                        score.value += 2;
                        score.details.push('Sitemap includes update dates');
                        score.checks.push({ name: 'Lastmod dates', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Lastmod dates', status: 'fail' });
                    }
                } else {
                    score.checks.push({ name: 'XML sitemap', status: 'fail' });
                    score.checks.push({ name: 'Lastmod dates', status: 'fail' });
                }
                
                // Check for RSS feed
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    const rssFeed = doc.querySelector('link[type="application/rss+xml"], link[type="application/atom+xml"]');
                    if (rssFeed) {
                        score.value += 3;
                        score.details.push('RSS/Atom feed available');
                        score.checks.push({ name: 'RSS/JSON feed', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'RSS/JSON feed', status: 'fail' });
                    }
                    
                    // Check for recent content indicators
                    const currentYear = new Date().getFullYear();
                    if (htmlContent.includes(currentYear.toString())) {
                        score.value += 2;
                        score.details.push('Current year content found');
                        score.checks.push({ name: 'Recent content', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Recent content', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check freshness signals');
            }
            
            return score;
        }

        async function checkTechnical(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check page load time (basic check)
                    const startTime = performance.now();
                    await fetchWithCORS(baseUrl);
                    const loadTime = performance.now() - startTime;
                    
                    if (loadTime < 3000) {
                        score.value += 3;
                        score.details.push('Fast load time');
                        score.checks.push({ name: 'Page speed', status: 'pass' });
                    } else if (loadTime < 5000) {
                        score.value += 1;
                        score.checks.push({ name: 'Page speed', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Page speed', status: 'fail' });
                    }
                    
                    // Check for semantic HTML5 elements
                    const hasArticle = doc.querySelector('article') !== null;
                    const hasHeader = doc.querySelector('header') !== null;
                    const hasFooter = doc.querySelector('footer') !== null;
                    const hasMain = doc.querySelector('main') !== null;
                    
                    const semanticScore = [hasArticle, hasHeader, hasFooter, hasMain].filter(Boolean).length;
                    if (semanticScore >= 3) {
                        score.value += 3;
                        score.details.push('Clean HTML structure');
                        score.checks.push({ name: 'HTML5 structure', status: 'pass' });
                    } else if (semanticScore >= 2) {
                        score.value += 1;
                        score.checks.push({ name: 'HTML5 structure', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'HTML5 structure', status: 'fail' });
                    }
                    
                    // Check for alt text on images
                    const images = doc.querySelectorAll('img');
                    const imagesWithAlt = doc.querySelectorAll('img[alt]');
                    
                    if (images.length > 0 && imagesWithAlt.length / images.length > 0.8) {
                        score.value += 2;
                        score.details.push('Good alt text coverage');
                        score.checks.push({ name: 'Image alt text', status: 'pass' });
                    } else if (images.length > 0 && imagesWithAlt.length / images.length > 0.5) {
                        score.value += 1;
                        score.checks.push({ name: 'Image alt text', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Image alt text', status: 'fail' });
                    }
                    
                    // Check mobile viewport
                    const viewport = doc.querySelector('meta[name="viewport"]');
                    if (viewport) {
                        score.value += 2;
                        score.details.push('Mobile-optimized');
                        score.checks.push({ name: 'Mobile ready', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Mobile ready', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check technical signals');
            }
            
            return score;
        }

        async function checkContentFormat(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for FAQ sections
                    const hasFAQ = htmlContent.toLowerCase().includes('faq') || 
                                  htmlContent.includes('frequently asked') ||
                                  htmlContent.includes('"@type":"FAQPage"');
                    
                    if (hasFAQ) {
                        score.value += 3;
                        score.details.push('FAQ section found');
                        score.checks.push({ name: 'FAQ content', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'FAQ content', status: 'fail' });
                    }
                    
                    // Check for lists and tables
                    const lists = doc.querySelectorAll('ul, ol');
                    const tables = doc.querySelectorAll('table');
                    
                    if (lists.length > 2 || tables.length > 0) {
                        score.value += 3;
                        score.details.push('Structured content formats');
                        score.checks.push({ name: 'Lists/Tables', status: 'pass' });
                    } else if (lists.length > 0) {
                        score.value += 1;
                        score.checks.push({ name: 'Lists/Tables', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Lists/Tables', status: 'fail' });
                    }
                    
                    // Check for definitions or glossary
                    const hasDefinitions = doc.querySelector('dl') !== null ||
                                         htmlContent.includes('definition') ||
                                         htmlContent.includes('glossary');
                    
                    if (hasDefinitions) {
                        score.value += 2;
                        score.details.push('Definitions/glossary present');
                        score.checks.push({ name: 'Definitions', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Definitions', status: 'fail' });
                    }
                    
                    // Check content depth
                    const wordCount = doc.body ? doc.body.textContent.split(/\s+/).length : 0;
                    if (wordCount > 1000) {
                        score.value += 2;
                        score.details.push('Comprehensive content');
                        score.checks.push({ name: 'Content depth', status: 'pass' });
                    } else if (wordCount > 500) {
                        score.value += 1;
                        score.checks.push({ name: 'Content depth', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Content depth', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check content formats');
            }
            
            return score;
        }

        async function checkLicensing(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                // Check robots.txt for differentiation
                const robotsUrl = `${baseUrl}/robots.txt`;
                const robotsContent = await fetchWithCORS(robotsUrl);
                
                if (robotsContent) {
                    // Check for training vs retrieval bot differentiation
                    const hasGPTBot = robotsContent.includes('GPTBot');
                    const hasSearchBot = robotsContent.includes('OAI-SearchBot') || robotsContent.includes('ChatGPT-User');
                    
                    if (hasGPTBot && hasSearchBot) {
                        score.value += 4;
                        score.details.push('Differentiates bot types');
                        score.checks.push({ name: 'Bot differentiation', status: 'pass' });
                    } else if (hasGPTBot || hasSearchBot) {
                        score.value += 2;
                        score.checks.push({ name: 'Bot differentiation', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Bot differentiation', status: 'fail' });
                    }
                    
                    // Check for llms.txt
                    if (robotsContent.includes('llms.txt')) {
                        score.value += 3;
                        score.details.push('llms.txt configured');
                        score.checks.push({ name: 'llms.txt policy', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'llms.txt policy', status: 'fail' });
                    }
                }
                
                // Check for terms/license page
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const hasTerms = htmlContent.includes('terms') || 
                                   htmlContent.includes('license') ||
                                   htmlContent.includes('copyright');
                    
                    if (hasTerms) {
                        score.value += 3;
                        score.details.push('License/terms present');
                        score.checks.push({ name: 'Terms/License', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Terms/License', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check licensing');
            }
            
            return score;
        }

        function checkCitationMonitoring() {
            // This would require actual API access to check
            // For now, provide guidance on what to check manually
            const score = { value: 5, max: 10, details: [], checks: [] };
            
            score.details.push('Manual verification needed');
            score.checks.push({ name: 'ChatGPT citations', status: 'partial' });
            score.checks.push({ name: 'Perplexity inclusion', status: 'partial' });
            score.checks.push({ name: 'Google AI Overviews', status: 'partial' });
            
            return score;
        }

        function checkCompetitive() {
            // This would require competitor analysis
            // For now, provide baseline score
            const score = { value: 5, max: 10, details: [], checks: [] };
            
            score.details.push('Competitor analysis needed');
            score.checks.push({ name: 'Market position', status: 'partial' });
            score.checks.push({ name: 'Content gaps', status: 'partial' });
            score.checks.push({ name: 'Schema advantage', status: 'partial' });
            
            return score;
        }

        function updateProgress(percent, message) {
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = percent + '%';
            progressBar.textContent = percent + '%';
            
            const loadingSection = document.getElementById('loadingSection');
            const statusText = loadingSection.querySelector('p');
            statusText.textContent = message;
        }

        function calculateTotalScore() {
            let total = 0;
            for (const factor in analysisResults.factors) {
                total += analysisResults.factors[factor].value;
            }
            analysisResults.totalScore = Math.round(total);
        }

        function displayResults() {
            const resultsSection = document.getElementById('resultsSection');
            
            // Display total score with animation
            animateScore(analysisResults.totalScore);
            
            // Display factor cards
            displayFactors();
            
            // Generate recommendations
            generateRecommendations();
            
            // Show results
            resultsSection.classList.add('active');
        }

        function animateScore(targetScore) {
            const scoreElement = document.getElementById('totalScore');
            const scoreCircle = document.getElementById('scoreCircle');
            const scoreStatus = document.getElementById('scoreStatus');
            
            // Animate number
            let currentScore = 0;
            const increment = targetScore / 50;
            const timer = setInterval(() => {
                currentScore += increment;
                if (currentScore >= targetScore) {
                    currentScore = targetScore;
                    clearInterval(timer);
                }
                scoreElement.textContent = Math.round(currentScore);
            }, 20);
            
            // Animate circle
            const circumference = 2 * Math.PI * 90;
            const offset = circumference - (targetScore / 100) * circumference;
            scoreCircle.style.strokeDashoffset = offset;
            
            // Set status message
            if (targetScore >= 80) {
                scoreStatus.textContent = 'Excellent LLM Visibility';
                scoreStatus.style.color = '#4caf50';
            } else if (targetScore >= 60) {
                scoreStatus.textContent = 'Good LLM Visibility';
                scoreStatus.style.color = '#ff9800';
            } else if (targetScore >= 40) {
                scoreStatus.textContent = 'Moderate LLM Visibility';
                scoreStatus.style.color = '#ff9800';
            } else {
                scoreStatus.textContent = 'Needs Improvement';
                scoreStatus.style.color = '#f44336';
            }
        }

        function displayFactors() {
            const factorsGrid = document.getElementById('factorsGrid');
            factorsGrid.innerHTML = '';
            
            const factorNames = {
                botAccessibility: 'Bot Accessibility',
                parsability: 'Parsability & Structure',
                citationFriendliness: 'Citation Friendliness',
                authority: 'Authority & Trust',
                freshness: 'Freshness & Feeds',
                technical: 'Technical Signals',
                contentFormat: 'Content Format',
                licensing: 'Licensing Readiness',
                citationMonitoring: 'Citation Monitoring',
                competitive: 'Competitive Position'
            };
            
            for (const [key, factor] of Object.entries(analysisResults.factors)) {
                const card = createFactorCard(factorNames[key], factor);
                factorsGrid.appendChild(card);
            }
        }

        function createFactorCard(name, factor) {
            const card = document.createElement('div');
            card.className = 'factor-card';
            
            const scoreColor = factor.value >= 8 ? '#4caf50' : 
                             factor.value >= 5 ? '#ff9800' : '#f44336';
            
            card.innerHTML = `
                <div class="factor-header">
                    <div class="factor-title">${name}</div>
                    <div class="factor-score" style="color: ${scoreColor}">${factor.value}/${factor.max}</div>
                </div>
                <div class="factor-details">${factor.details.join(', ') || 'No details available'}</div>
                <ul class="factor-items">
                    ${factor.checks.map(check => `
                        <li>
                            <span class="check-icon ${check.status}">
                                ${check.status === 'pass' ? 'âœ“' : check.status === 'partial' ? '~' : 'âœ—'}
                            </span>
                            ${check.name}
                        </li>
                    `).join('')}
                </ul>
            `;
            
            return card;
        }

        function generateRecommendations() {
            const recommendations = document.getElementById('recommendations');
            const recs = [];
            
            // Analyze weak points and generate recommendations
            for (const [key, factor] of Object.entries(analysisResults.factors)) {
                if (factor.value < 6) {
                    recs.push(getRecommendation(key, factor));
                }
            }
            
            // Sort by priority (lowest scores first)
            recs.sort((a, b) => a.score - b.score);
            
            // Take top 3
            const topRecs = recs.slice(0, 3);
            
            recommendations.innerHTML = `
                <h2>ðŸ“‹ Top Recommendations</h2>
                ${topRecs.map((rec, index) => `
                    <div class="recommendation-item">
                        <span class="recommendation-priority">Priority ${index + 1}</span>
                        <div class="recommendation-title">${rec.title}</div>
                        <p>${rec.description}</p>
                        <ol class="recommendation-steps">
                            ${rec.steps.map(step => `<li>${step}</li>`).join('')}
                        </ol>
                    </div>
                `).join('')}
            `;
        }

        function getRecommendation(factorKey, factor) {
            const recommendations = {
                botAccessibility: {
                    title: 'Improve Bot Accessibility',
                    description: 'AI bots cannot properly access your site. This is critical for LLM visibility.',
                    steps: [
                        'Create or update robots.txt file in your root directory',
                        'Add these lines: User-agent: GPTBot\\nAllow: /',
                        'Add similar entries for ClaudeBot, OAI-SearchBot, and PerplexityBot',
                        'Create an llms.txt file listing your best content URLs',
                        'Test accessibility at robotstxt.com'
                    ]
                },
                parsability: {
                    title: 'Enhance Content Structure',
                    description: 'Your content structure needs improvement for AI understanding.',
                    steps: [
                        'Add clear H1 tags to all main pages (one per page)',
                        'Use H2 and H3 tags to create content hierarchy',
                        'Implement Schema.org markup using JSON-LD format',
                        'Add semantic HTML5 tags: <article>, <main>, <section>',
                        'Validate markup at schema.org/docs/validator'
                    ]
                },
                citationFriendliness: {
                    title: 'Make Content More Citable',
                    description: 'Your content is difficult for AI to quote and reference.',
                    steps: [
                        'Add author names to all content pieces',
                        'Include publication and update dates prominently',
                        'Break long content into 40-120 word paragraphs',
                        'Add internal links to related content',
                        'Include meta author and date tags in HTML head'
                    ]
                },
                authority: {
                    title: 'Build Trust Signals',
                    description: 'Your site lacks authority indicators that AI systems look for.',
                    steps: [
                        'Create comprehensive About and Contact pages',
                        'Add author bios with credentials to content',
                        'Display testimonials, reviews, or case studies',
                        'Ensure HTTPS is enabled site-wide',
                        'Add trust badges and certifications if applicable'
                    ]
                },
                freshness: {
                    title: 'Show Content Freshness',
                    description: 'AI cannot determine if your content is current.',
                    steps: [
                        'Create and submit XML sitemap with lastmod dates',
                        'Add RSS or Atom feed for new content',
                        'Display "Last Updated" dates on all pages',
                        'Update content regularly (at least monthly)',
                        'Include current year references in content'
                    ]
                },
                technical: {
                    title: 'Fix Technical Issues',
                    description: 'Technical problems make your site hard for AI to process.',
                    steps: [
                        'Improve page load speed (target under 3 seconds)',
                        'Add alt text to all images describing their content',
                        'Implement proper HTML5 semantic structure',
                        'Add viewport meta tag for mobile optimization',
                        'Test with Google PageSpeed Insights'
                    ]
                },
                contentFormat: {
                    title: 'Add AI-Friendly Formats',
                    description: 'Your content formats are not optimized for AI extraction.',
                    steps: [
                        'Create FAQ sections with clear Q&A format',
                        'Add comparison tables and feature lists',
                        'Include definitions and glossaries for key terms',
                        'Use bullet points and numbered lists',
                        'Aim for 1000+ words on key topic pages'
                    ]
                },
                licensing: {
                    title: 'Prepare for AI Licensing',
                    description: 'Your site is not ready for AI content usage policies.',
                    steps: [
                        'Differentiate bot permissions in robots.txt',
                        'Create llms.txt with content guidelines',
                        'Add terms of service page addressing AI usage',
                        'Consider AI publisher programs (OpenAI, Perplexity)',
                        'Document your AI content policy clearly'
                    ]
                }
            };
            
            return {
                score: factor.value,
                ...recommendations[factorKey] || {
                    title: 'General Improvement',
                    description: 'This area needs attention.',
                    steps: ['Review best practices', 'Implement improvements', 'Test changes']
                }
            };
        }

        function showError(message) {
            document.getElementById('errorSection').style.display = 'block';
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('loadingSection').style.display = 'none';
        }

        // Allow Enter key to trigger analysis
        document.getElementById('domainInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                analyzeDomain();
            }
        });
    </script>
</body>
</html>
