<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Visibility Diagnosis Tool - Multi-Page Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.95;
        }

        .input-section {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .analysis-mode {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mode-option {
            position: relative;
        }

        .mode-option input[type="radio"] {
            position: absolute;
            opacity: 0;
        }

        .mode-option label {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            padding: 15px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            transition: all 0.3s;
            min-width: 150px;
        }

        .mode-option label:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .mode-option input[type="radio"]:checked + label {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea10, #764ba210);
        }

        .mode-option .mode-icon {
            font-size: 1.5rem;
        }

        .mode-option .mode-title {
            font-weight: 600;
            color: #333;
        }

        .mode-option .mode-desc {
            font-size: 0.8rem;
            color: #999;
        }

        .input-group {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .multi-input-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .url-row {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .url-row label {
            min-width: 140px;
            font-weight: 600;
            color: #666;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .url-row .required {
            color: #f44336;
        }

        .url-row input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s;
        }

        .url-row input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
        }

        input[type="text"] {
            flex: 1;
            padding: 15px 20px;
            font-size: 1.1rem;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            transition: all 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
        }

        .analyze-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102,126,234,0.3);
        }

        .analyze-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .page-breakdown {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .page-summary h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.4rem;
        }

        .page-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .page-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 3px solid #667eea;
            transition: all 0.3s;
        }

        .page-item:hover {
            background: #e8ebff;
        }

        .page-path {
            color: #666;
            font-family: monospace;
            font-size: 0.95rem;
        }

        .page-score {
            font-weight: bold;
            color: #667eea;
            font-size: 1.1rem;
        }

        .aggregation-note {
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
            color: #999;
            font-size: 0.9rem;
            font-style: italic;
        }

        .results-section {
            display: none;
        }

        .results-section.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .overall-score {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .score-circle {
            width: 200px;
            height: 200px;
            margin: 0 auto 20px;
            position: relative;
        }

        .score-circle svg {
            transform: rotate(-90deg);
        }

        .score-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #333;
        }

        .score-label {
            font-size: 1.3rem;
            color: #666;
            margin-bottom: 10px;
        }

        .score-status {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 10px;
        }

        .factors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .factor-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            transition: all 0.3s;
        }

        .factor-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.12);
        }

        .factor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .factor-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
        }

        .factor-score {
            font-size: 1.3rem;
            font-weight: bold;
            padding: 5px 15px;
            border-radius: 20px;
            background: #f5f5f5;
        }

        .factor-details {
            color: #666;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .factor-items {
            list-style: none;
        }

        .factor-items li {
            padding: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .check-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }

        .check-icon.pass {
            background: #4caf50;
        }

        .check-icon.fail {
            background: #f44336;
        }

        .check-icon.partial {
            background: #ff9800;
        }

        .recommendations {
            background: white;
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .recommendations h2 {
            color: #333;
            margin-bottom: 25px;
            font-size: 1.8rem;
        }

        .recommendation-item {
            background: linear-gradient(135deg, #667eea10, #764ba210);
            border-left: 4px solid #667eea;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
        }

        .recommendation-priority {
            display: inline-block;
            padding: 5px 15px;
            background: #667eea;
            color: white;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .recommendation-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .recommendation-steps {
            margin-top: 15px;
            padding-left: 20px;
        }

        .recommendation-steps li {
            margin-bottom: 8px;
            color: #666;
            line-height: 1.6;
        }

        .loading {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 20px;
            margin-bottom: 30px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #c62828;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #f5f5f5;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 15px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }

        .help-text {
            color: #999;
            font-size: 0.85rem;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🤖 LLM Visibility Diagnosis Tool</h1>
            <p>Analyze how well AI assistants can discover, understand, and cite your website</p>
            <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 5px;">8 Real Factors • Multi-Page Analysis • 100% Verified</p>
        </div>

        <div class="input-section">
            <div class="analysis-mode">
                <div class="mode-option">
                    <input type="radio" name="mode" id="single" value="single" checked>
                    <label for="single">
                        <span class="mode-icon">📄</span>
                        <span class="mode-title">Single Page</span>
                        <span class="mode-desc">Quick analysis</span>
                    </label>
                </div>
                <div class="mode-option">
                    <input type="radio" name="mode" id="multi" value="multi">
                    <label for="multi">
                        <span class="mode-icon">📚</span>
                        <span class="mode-title">Multi-Page</span>
                        <span class="mode-desc">Better accuracy</span>
                    </label>
                </div>
                <div class="mode-option">
                    <input type="radio" name="mode" id="auto" value="auto">
                    <label for="auto">
                        <span class="mode-icon">🔍</span>
                        <span class="mode-title">Auto-Discovery</span>
                        <span class="mode-desc">Via sitemap</span>
                    </label>
                </div>
            </div>
            
            <!-- Single Page Mode -->
            <div id="singleMode" class="input-group">
                <input type="text" id="domainInput" placeholder="Enter domain (e.g., example.com)" />
                <button class="analyze-btn" onclick="analyzeDomain()">Analyze Website</button>
            </div>
            
            <!-- Multi Page Mode -->
            <div id="multiMode" class="multi-input-group" style="display: none;">
                <div class="url-row">
                    <label>🏠 Homepage <span class="required">*</span></label>
                    <input type="text" id="url1" placeholder="https://example.com" />
                </div>
                <div class="url-row">
                    <label>📝 Blog/Article</label>
                    <input type="text" id="url2" placeholder="https://example.com/blog/article (optional)" />
                </div>
                <div class="url-row">
                    <label>🛍️ Product Page</label>
                    <input type="text" id="url3" placeholder="https://example.com/product (optional)" />
                </div>
                <div class="url-row">
                    <label>ℹ️ About Page</label>
                    <input type="text" id="url4" placeholder="https://example.com/about (optional)" />
                </div>
                <button class="analyze-btn" onclick="analyzeMultiple()">Analyze All Pages</button>
                <p class="help-text">💡 Tip: Analyzing multiple pages gives you a more accurate overall score</p>
            </div>
            
            <!-- Auto Discovery Mode -->
            <div id="autoMode" class="input-group" style="display: none;">
                <input type="text" id="domainAutoInput" placeholder="Enter domain (e.g., example.com)" />
                <button class="analyze-btn" onclick="analyzeAuto()">Auto-Discover & Analyze</button>
            </div>
        </div>

        <div id="loadingSection" class="loading" style="display: none;">
            <div class="spinner"></div>
            <p id="loadingMessage">Analyzing website visibility for AI assistants...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%">0%</div>
            </div>
        </div>

        <div id="errorSection" style="display: none;">
            <div class="error-message" id="errorMessage"></div>
        </div>

        <div id="resultsSection" class="results-section">
            <div id="pageBreakdown"></div>
            
            <div class="overall-score">
                <div class="score-circle">
                    <svg width="200" height="200">
                        <circle cx="100" cy="100" r="90" stroke="#e0e0e0" stroke-width="20" fill="none"/>
                        <circle id="scoreCircle" cx="100" cy="100" r="90" stroke="url(#gradient)" stroke-width="20" fill="none" 
                                stroke-dasharray="565" stroke-dashoffset="565" stroke-linecap="round"/>
                        <defs>
                            <linearGradient id="gradient">
                                <stop offset="0%" stop-color="#667eea"/>
                                <stop offset="100%" stop-color="#764ba2"/>
                            </linearGradient>
                        </defs>
                    </svg>
                    <div class="score-number" id="totalScore">0</div>
                </div>
                <div class="score-label">LLM Visibility Score (out of 80)</div>
                <div class="score-status" id="scoreStatus">Calculating...</div>
            </div>

            <div class="factors-grid" id="factorsGrid"></div>

            <div class="recommendations" id="recommendations"></div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION - YOUR VERCEL URL =====
        const PROXY_BASE_URL = 'https://llm-visibility-tool-chi.vercel.app/api/analyze';
        
        // Configuration for bot checking
        const AI_BOTS = ['GPTBot', 'OAI-SearchBot', 'ClaudeBot', 'PerplexityBot', 'ChatGPT-User', 'CCBot', 'Amazonbot', 'Applebot'];
        
        let analysisResults = {};
        let currentMode = 'single';

        // Mode switching
        document.querySelectorAll('input[name="mode"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                currentMode = e.target.value;
                toggleAnalysisMode(currentMode);
            });
        });

        function toggleAnalysisMode(mode) {
            // Hide all modes
            document.getElementById('singleMode').style.display = 'none';
            document.getElementById('multiMode').style.display = 'none';
            document.getElementById('autoMode').style.display = 'none';
            
            // Show selected mode
            if (mode === 'single') {
                document.getElementById('singleMode').style.display = 'flex';
            } else if (mode === 'multi') {
                document.getElementById('multiMode').style.display = 'block';
            } else if (mode === 'auto') {
                document.getElementById('autoMode').style.display = 'flex';
            }
        }

        // ===== SINGLE PAGE ANALYSIS (Original) =====
        async function analyzeDomain() {
            const domainInput = document.getElementById('domainInput');
            const domain = domainInput.value.trim().replace(/^https?:\/\//, '').replace(/\/$/, '');
            
            if (!domain) {
                showError('Please enter a valid domain');
                return;
            }

            // Clear any previous page breakdown
            document.getElementById('pageBreakdown').innerHTML = '';

            // Reset and show loading
            document.getElementById('resultsSection').classList.remove('active');
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('loadingSection').style.display = 'block';
            
            try {
                await performAnalysis(domain);
            } catch (error) {
                showError(`Analysis failed: ${error.message}. Please ensure the domain is accessible and try again.`);
            } finally {
                document.getElementById('loadingSection').style.display = 'none';
            }
        }

        async function performAnalysis(domain) {
            analysisResults = {
                domain: domain,
                factors: {},
                totalScore: 0
            };

            const baseUrl = `https://${domain}`;
            
            // Update progress
            updateProgress(12, 'Checking bot accessibility...');
            analysisResults.factors.botAccessibility = await checkBotAccessibility(baseUrl);
            
            updateProgress(24, 'Analyzing content structure...');
            analysisResults.factors.parsability = await checkParsability(baseUrl);
            
            updateProgress(36, 'Evaluating citation friendliness...');
            analysisResults.factors.citationFriendliness = await checkCitationFriendliness(baseUrl);
            
            updateProgress(48, 'Assessing authority signals...');
            analysisResults.factors.authority = await checkAuthority(baseUrl);
            
            updateProgress(60, 'Checking content freshness...');
            analysisResults.factors.freshness = await checkFreshness(baseUrl);
            
            updateProgress(72, 'Analyzing technical signals...');
            analysisResults.factors.technical = await checkTechnical(baseUrl);
            
            updateProgress(84, 'Reviewing content formats...');
            analysisResults.factors.contentFormat = await checkContentFormat(baseUrl);
            
            updateProgress(96, 'Checking licensing readiness...');
            analysisResults.factors.licensing = await checkLicensing(baseUrl);
            
            updateProgress(100, 'Generating report...');
            
            // Calculate total score
            calculateTotalScore();
            
            // Display results
            displayResults();
        }

        // ===== MULTI-PAGE ANALYSIS =====
        async function analyzeMultiple() {
            const urls = [
                document.getElementById('url1').value.trim(),
                document.getElementById('url2').value.trim(),
                document.getElementById('url3').value.trim(),
                document.getElementById('url4').value.trim()
            ].filter(url => url && url.length > 0);
            
            if (urls.length === 0) {
                showError('Please enter at least the homepage URL');
                return;
            }
            
            // Reset and show loading
            document.getElementById('resultsSection').classList.remove('active');
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('loadingSection').style.display = 'block';
            
            try {
                const allResults = {
                    domain: new URL(urls[0].startsWith('http') ? urls[0] : 'https://' + urls[0]).hostname,
                    pages: [],
                    aggregatedFactors: {},
                    totalScore: 0,
                    pageCount: urls.length
                };
                
                // Analyze each page
                for (let i = 0; i < urls.length; i++) {
                    let url = urls[i];
                    if (!url.startsWith('http')) {
                        url = 'https://' + url;
                    }
                    
                    const pathname = new URL(url).pathname || '/';
                    const progress = Math.round((i / urls.length) * 90);
                    updateProgress(progress, `Analyzing page ${i + 1} of ${urls.length}: ${pathname}`);
                    
                    const pageResults = await analyzeOnePage(url);
                    allResults.pages.push({
                        url: url,
                        path: pathname,
                        factors: pageResults
                    });
                }
                
                updateProgress(95, 'Combining results...');
                
                // Aggregate results
                allResults.aggregatedFactors = aggregatePageResults(allResults.pages);
                allResults.totalScore = calculateAggregatedScore(allResults.aggregatedFactors);
                
                // Display multi-page results
                displayMultiPageResults(allResults);
                
            } catch (error) {
                showError(`Analysis failed: ${error.message}`);
            } finally {
                document.getElementById('loadingSection').style.display = 'none';
            }
        }

        async function analyzeOnePage(url) {
            const results = {};
            
            try {
                // Parse URL properly
                if (!url.startsWith('http')) {
                    url = 'https://' + url;
                }
                const parsedUrl = new URL(url);
                const baseUrl = parsedUrl.origin;
                
                // Run all checks for this specific page
                results.botAccessibility = await checkBotAccessibility(baseUrl);
                results.parsability = await checkParsability(url);
                results.citationFriendliness = await checkCitationFriendliness(url);
                results.authority = await checkAuthority(url);
                results.freshness = await checkFreshness(baseUrl);
                results.technical = await checkTechnical(url);
                results.contentFormat = await checkContentFormat(url);
                results.licensing = await checkLicensing(baseUrl);
                
            } catch (error) {
                console.error(`Error analyzing ${url}:`, error);
                // Return empty factors if page fails
                const emptyFactor = { value: 0, max: 10, details: ['Failed to analyze'], checks: [] };
                return {
                    botAccessibility: emptyFactor,
                    parsability: emptyFactor,
                    citationFriendliness: emptyFactor,
                    authority: emptyFactor,
                    freshness: emptyFactor,
                    technical: emptyFactor,
                    contentFormat: emptyFactor,
                    licensing: emptyFactor
                };
            }
            
            return results;
        }

        function aggregatePageResults(pages) {
            const aggregated = {};
            const factorNames = [
                'botAccessibility', 'parsability', 'citationFriendliness',
                'authority', 'freshness', 'technical', 'contentFormat', 'licensing'
            ];
            
            factorNames.forEach(factor => {
                // Collect scores from all pages
                const scores = pages
                    .map(p => p.factors[factor])
                    .filter(f => f && f.value !== undefined);
                
                if (scores.length > 0) {
                    // For site-wide factors, take the MAX
                    // For page-specific factors, take the AVERAGE
                    const useMax = ['botAccessibility', 'licensing', 'freshness'].includes(factor);
                    
                    if (useMax) {
                        // Use best score (e.g., robots.txt only needs to be set once)
                        aggregated[factor] = scores.reduce((best, current) => 
                            current.value > best.value ? current : best
                        );
                        aggregated[factor].details.push(`Best of ${scores.length} pages`);
                    } else {
                        // Average across pages
                        const avgValue = Math.round(
                            scores.reduce((sum, s) => sum + s.value, 0) / scores.length
                        );
                        
                        // Combine all checks and details
                        const allDetails = new Set();
                        const allChecks = [];
                        
                        scores.forEach(score => {
                            score.details.forEach(d => allDetails.add(d));
                            if (score.checks && score.checks.length > 0) {
                                score.checks.forEach(check => {
                                    const existing = allChecks.find(c => c.name === check.name);
                                    if (!existing) {
                                        allChecks.push(check);
                                    }
                                });
                            }
                        });
                        
                        aggregated[factor] = {
                            value: avgValue,
                            max: scores[0].max,
                            details: [`Averaged from ${scores.length} pages`, ...Array.from(allDetails)],
                            checks: allChecks
                        };
                    }
                }
            });
            
            return aggregated;
        }

        function calculateAggregatedScore(factors) {
            let total = 0;
            for (const factor in factors) {
                total += factors[factor].value || 0;
            }
            return Math.round(total);
        }

        function calculatePageScore(factors) {
            let total = 0;
            for (const factor in factors) {
                if (factors[factor] && factors[factor].value) {
                    total += factors[factor].value;
                }
            }
            return Math.round(total);
        }

        function displayMultiPageResults(results) {
            // Show page breakdown
            const pageBreakdown = document.getElementById('pageBreakdown');
            pageBreakdown.innerHTML = `
                <div class="page-breakdown">
                    <div class="page-summary">
                        <h3>📊 Analyzed ${results.pageCount} Pages</h3>
                        <div class="page-list">
                            ${results.pages.map((page, index) => `
                                <div class="page-item">
                                    <span class="page-path">Page ${index + 1}: ${page.path}</span>
                                    <span class="page-score">${calculatePageScore(page.factors)}/80</span>
                                </div>
                            `).join('')}
                        </div>
                        <div class="aggregation-note">
                            Site-wide factors (robots.txt, SSL) use best score • Content factors use average score
                        </div>
                    </div>
                </div>
            `;
            
            // Update the global results for display
            analysisResults = {
                domain: results.domain,
                factors: results.aggregatedFactors,
                totalScore: results.totalScore
            };
            
            // Use existing display functions
            animateScore(results.totalScore);
            displayFactors();
            generateRecommendations();
            
            // Show results
            document.getElementById('resultsSection').classList.add('active');
        }

        // ===== AUTO-DISCOVERY ANALYSIS =====
        async function analyzeAuto() {
            const domain = document.getElementById('domainAutoInput').value.trim().replace(/^https?:\/\//, '').replace(/\/$/, '');
            
            if (!domain) {
                showError('Please enter a domain');
                return;
            }
            
            // Reset and show loading
            document.getElementById('resultsSection').classList.remove('active');
            document.getElementById('errorSection').style.display = 'none';
            document.getElementById('loadingSection').style.display = 'block';
            
            try {
                const baseUrl = `https://${domain}`;
                
                updateProgress(10, 'Looking for sitemap...');
                
                // Try to get sitemap
                const sitemapXml = await fetchWithCORS(`${baseUrl}/sitemap.xml`, 'sitemap');
                
                let urls = [];
                
                if (sitemapXml && sitemapXml.includes('<loc>')) {
                    // Parse URLs from sitemap
                    urls = parseSitemapUrls(sitemapXml, baseUrl);
                    updateProgress(20, `Found ${urls.length} pages in sitemap`);
                    
                    // Sample key pages (max 5)
                    urls = selectKeyPages(urls, 5);
                    updateProgress(30, `Selected ${urls.length} key pages to analyze`);
                } else {
                    // No sitemap, use common pages
                    updateProgress(20, 'No sitemap found, checking common pages...');
                    urls = [
                        baseUrl,
                        `${baseUrl}/about`,
                        `${baseUrl}/blog`,
                        `${baseUrl}/products`,
                        `${baseUrl}/services`
                    ];
                    
                    // Check which URLs actually exist
                    const validUrls = [];
                    for (const url of urls) {
                        const exists = await checkUrlExists(url);
                        if (exists) {
                            validUrls.push(url);
                        }
                    }
                    urls = validUrls.slice(0, 5);
                    updateProgress(30, `Found ${urls.length} pages to analyze`);
                }
                
                if (urls.length === 0) {
                    urls = [baseUrl]; // At least analyze homepage
                }
                
                // Now analyze these pages
                const allResults = {
                    domain: domain,
                    pages: [],
                    aggregatedFactors: {},
                    totalScore: 0,
                    pageCount: urls.length
                };
                
                for (let i = 0; i < urls.length; i++) {
                    const progress = 30 + (i / urls.length) * 60;
                    const pathname = new URL(urls[i]).pathname || '/';
                    updateProgress(progress, `Analyzing page ${i + 1} of ${urls.length}: ${pathname}`);
                    
                    const pageResults = await analyzeOnePage(urls[i]);
                    allResults.pages.push({
                        url: urls[i],
                        path: pathname,
                        factors: pageResults
                    });
                }
                
                updateProgress(95, 'Combining results...');
                
                // Aggregate and display
                allResults.aggregatedFactors = aggregatePageResults(allResults.pages);
                allResults.totalScore = calculateAggregatedScore(allResults.aggregatedFactors);
                
                displayMultiPageResults(allResults);
                
            } catch (error) {
                showError(`Auto-discovery failed: ${error.message}`);
            } finally {
                document.getElementById('loadingSection').style.display = 'none';
            }
        }

        function parseSitemapUrls(xml, baseUrl) {
            const urls = [];
            
            // Extract URLs from <loc> tags using regex
            const locRegex = /<loc>(.*?)<\/loc>/g;
            let match;
            
            while ((match = locRegex.exec(xml)) !== null) {
                const url = match[1];
                if (url && url.startsWith(baseUrl)) {
                    urls.push(url);
                }
            }
            
            return urls;
        }

        function selectKeyPages(urls, maxCount = 5) {
            // Prioritize important pages
            const priorities = [
                { pattern: /^\/?$/, weight: 10 },           // Homepage
                { pattern: /\/about/i, weight: 9 },         // About page
                { pattern: /\/product/i, weight: 7 },       // Products
                { pattern: /\/service/i, weight: 7 },       // Services
                { pattern: /\/blog\/[^\/]+$/i, weight: 6 }, // Blog posts
                { pattern: /\/contact/i, weight: 5 },       // Contact
                { pattern: /\/faq/i, weight: 5 }            // FAQ
            ];
            
            // Score each URL
            const scoredUrls = urls.map(url => {
                let score = 1;
                const path = new URL(url).pathname;
                
                priorities.forEach(p => {
                    if (p.pattern.test(path)) {
                        score = Math.max(score, p.weight);
                    }
                });
                
                return { url, score };
            });
            
            // Sort by score and take top N
            scoredUrls.sort((a, b) => b.score - a.score);
            
            // Always include homepage if available
            const homepage = urls.find(u => new URL(u).pathname === '/' || new URL(u).pathname === '');
            const selected = homepage ? [homepage] : [];
            
            // Add other pages
            for (const item of scoredUrls) {
                if (!selected.includes(item.url) && selected.length < maxCount) {
                    selected.push(item.url);
                }
            }
            
            return selected.slice(0, maxCount);
        }

        async function checkUrlExists(url) {
            try {
                const response = await fetch(PROXY_BASE_URL + '?url=' + encodeURIComponent(url));
                const data = await response.json();
                return data.success;
            } catch {
                return false;
            }
        }

        // ===== SHARED ANALYSIS FUNCTIONS =====
        async function fetchWithCORS(url, type = 'html') {
            try {
                // Extract domain from URL if it's a full URL
                let domain = url.replace(/^https?:\/\//, '').replace(/\/$/, '');
                
                // For specific resources, extract just the domain
                if (url.includes('/robots.txt')) {
                    domain = new URL(url).hostname;
                    type = 'robots';
                } else if (url.includes('/sitemap.xml')) {
                    domain = new URL(url).hostname;
                    type = 'sitemap';
                } else if (url.includes('/llms.txt')) {
                    domain = new URL(url).hostname;
                    type = 'llms';
                }
                
                // Call your Vercel proxy
                const proxyUrl = `${PROXY_BASE_URL}?url=${encodeURIComponent(domain)}&type=${type}`;
                console.log('Fetching via proxy:', proxyUrl);
                
                const response = await fetch(proxyUrl);
                const data = await response.json();
                
                if (data.success) {
                    return data.content;
                } else {
                    console.error('Proxy error:', data.error);
                    return null;
                }
            } catch (error) {
                console.error('Fetch error:', error);
                return null;
            }
        }

        // [All the check functions remain the same]
        async function checkBotAccessibility(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                // Check robots.txt
                const robotsUrl = `${baseUrl}/robots.txt`;
                const robotsContent = await fetchWithCORS(robotsUrl);
                
                if (robotsContent) {
                    score.details.push('robots.txt found');
                    score.checks.push({ name: 'robots.txt exists', status: 'pass' });
                    score.value += 3;
                    
                    // Check for AI bot allowances
                    const allowedBots = AI_BOTS.filter(bot => 
                        !robotsContent.includes(`User-agent: ${bot}\nDisallow: /`)
                    );
                    
                    if (allowedBots.length > 0) {
                        score.value += Math.min(4, allowedBots.length);
                        score.details.push(`${allowedBots.length} AI bots allowed`);
                        score.checks.push({ name: 'AI bots allowed', status: allowedBots.length > 2 ? 'pass' : 'partial' });
                    } else {
                        score.checks.push({ name: 'AI bots allowed', status: 'fail' });
                    }
                    
                    // Check for llms.txt
                    if (robotsContent.includes('llms.txt')) {
                        score.value += 2;
                        score.details.push('llms.txt reference found');
                        score.checks.push({ name: 'llms.txt configured', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'llms.txt configured', status: 'fail' });
                    }
                } else {
                    score.checks.push({ name: 'robots.txt exists', status: 'fail' });
                    score.checks.push({ name: 'AI bots allowed', status: 'fail' });
                    score.checks.push({ name: 'llms.txt configured', status: 'fail' });
                }
                
                // Check for llms.txt directly
                try {
                    const llmsUrl = `${baseUrl}/llms.txt`;
                    const llmsContent = await fetchWithCORS(llmsUrl);
                    if (llmsContent) {
                        score.value += 1;
                        score.details.push('llms.txt file exists');
                    }
                } catch (e) {
                    // llms.txt not found
                }
                
            } catch (error) {
                score.details.push('Unable to check bot accessibility');
            }
            
            return score;
        }

        async function checkParsability(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for proper heading structure
                    const h1Count = doc.querySelectorAll('h1').length;
                    const h2Count = doc.querySelectorAll('h2').length;
                    const h3Count = doc.querySelectorAll('h3').length;
                    
                    if (h1Count > 0) {
                        score.value += 2;
                        score.details.push('H1 tags found');
                        score.checks.push({ name: 'H1 headings present', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'H1 headings present', status: 'fail' });
                    }
                    
                    if (h2Count > 0 && h3Count > 0) {
                        score.value += 3;
                        score.details.push('Hierarchical heading structure');
                        score.checks.push({ name: 'H2-H3 hierarchy', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'H2-H3 hierarchy', status: h2Count > 0 ? 'partial' : 'fail' });
                    }
                    
                    // Check for schema markup
                    const schemaScripts = doc.querySelectorAll('script[type="application/ld+json"]');
                    if (schemaScripts.length > 0) {
                        score.value += 3;
                        score.details.push('Schema.org markup found');
                        score.checks.push({ name: 'Schema.org markup', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Schema.org markup', status: 'fail' });
                    }
                    
                    // Check for semantic HTML
                    const hasArticle = doc.querySelector('article') !== null;
                    const hasMain = doc.querySelector('main') !== null;
                    const hasNav = doc.querySelector('nav') !== null;
                    
                    if (hasArticle || hasMain) {
                        score.value += 2;
                        score.details.push('Semantic HTML structure');
                        score.checks.push({ name: 'Semantic HTML tags', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Semantic HTML tags', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to analyze page structure');
            }
            
            return score;
        }

        async function checkCitationFriendliness(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for author information
                    const authorMeta = doc.querySelector('meta[name="author"]');
                    const authorSchema = htmlContent.includes('"@type":"Person"') || htmlContent.includes('"author"');
                    
                    if (authorMeta || authorSchema) {
                        score.value += 3;
                        score.details.push('Author information present');
                        score.checks.push({ name: 'Author attribution', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Author attribution', status: 'fail' });
                    }
                    
                    // Check for dates
                    const dateMeta = doc.querySelector('meta[property="article:published_time"], meta[name="publish_date"], time');
                    if (dateMeta) {
                        score.value += 2;
                        score.details.push('Publication dates found');
                        score.checks.push({ name: 'Date information', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Date information', status: 'fail' });
                    }
                    
                    // Check for structured paragraphs
                    const paragraphs = doc.querySelectorAll('p');
                    let wellStructured = 0;
                    paragraphs.forEach(p => {
                        const text = p.textContent.trim();
                        if (text.length > 40 && text.length < 200) {
                            wellStructured++;
                        }
                    });
                    
                    if (wellStructured > 5) {
                        score.value += 3;
                        score.details.push('Well-structured paragraphs');
                        score.checks.push({ name: 'Concise paragraphs', status: 'pass' });
                    } else if (wellStructured > 2) {
                        score.value += 1;
                        score.checks.push({ name: 'Concise paragraphs', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Concise paragraphs', status: 'fail' });
                    }
                    
                    // Check for internal/external links
                    const links = doc.querySelectorAll('a[href]');
                    if (links.length > 10) {
                        score.value += 2;
                        score.details.push('Good link structure');
                        score.checks.push({ name: 'Link citations', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Link citations', status: links.length > 5 ? 'partial' : 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check citation structure');
            }
            
            return score;
        }

        async function checkAuthority(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for About page
                    const aboutLink = doc.querySelector('a[href*="about"], a[href*="About"]');
                    if (aboutLink) {
                        score.value += 3;
                        score.details.push('About page found');
                        score.checks.push({ name: 'About page', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'About page', status: 'fail' });
                    }
                    
                    // Check for Contact page
                    const contactLink = doc.querySelector('a[href*="contact"], a[href*="Contact"]');
                    if (contactLink) {
                        score.value += 3;
                        score.details.push('Contact page found');
                        score.checks.push({ name: 'Contact page', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Contact page', status: 'fail' });
                    }
                    
                    // Check for social proof / trust signals
                    const trustSignals = htmlContent.includes('testimonial') || 
                                       htmlContent.includes('review') || 
                                       htmlContent.includes('trusted by') ||
                                       htmlContent.includes('partner');
                    
                    if (trustSignals) {
                        score.value += 2;
                        score.details.push('Trust signals present');
                        score.checks.push({ name: 'Trust indicators', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Trust indicators', status: 'fail' });
                    }
                    
                    // Check for SSL
                    if (baseUrl.startsWith('https')) {
                        score.value += 2;
                        score.details.push('SSL certificate active');
                        score.checks.push({ name: 'SSL/HTTPS', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'SSL/HTTPS', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check authority signals');
            }
            
            return score;
        }

        async function checkFreshness(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                // Check for sitemap
                const sitemapUrl = `${baseUrl}/sitemap.xml`;
                const sitemapContent = await fetchWithCORS(sitemapUrl);
                
                if (sitemapContent) {
                    score.value += 3;
                    score.details.push('XML sitemap found');
                    score.checks.push({ name: 'XML sitemap', status: 'pass' });
                    
                    // Check for lastmod dates
                    if (sitemapContent.includes('<lastmod>')) {
                        score.value += 2;
                        score.details.push('Sitemap includes update dates');
                        score.checks.push({ name: 'Lastmod dates', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Lastmod dates', status: 'fail' });
                    }
                } else {
                    score.checks.push({ name: 'XML sitemap', status: 'fail' });
                    score.checks.push({ name: 'Lastmod dates', status: 'fail' });
                }
                
                // Check for RSS feed
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    const rssFeed = doc.querySelector('link[type="application/rss+xml"], link[type="application/atom+xml"]');
                    if (rssFeed) {
                        score.value += 3;
                        score.details.push('RSS/Atom feed available');
                        score.checks.push({ name: 'RSS/JSON feed', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'RSS/JSON feed', status: 'fail' });
                    }
                    
                    // Check for recent content indicators
                    const currentYear = new Date().getFullYear();
                    if (htmlContent.includes(currentYear.toString())) {
                        score.value += 2;
                        score.details.push('Current year content found');
                        score.checks.push({ name: 'Recent content', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Recent content', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check freshness signals');
            }
            
            return score;
        }

        async function checkTechnical(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for semantic HTML5 elements
                    const hasArticle = doc.querySelector('article') !== null;
                    const hasHeader = doc.querySelector('header') !== null;
                    const hasFooter = doc.querySelector('footer') !== null;
                    const hasMain = doc.querySelector('main') !== null;
                    
                    const semanticScore = [hasArticle, hasHeader, hasFooter, hasMain].filter(Boolean).length;
                    if (semanticScore >= 3) {
                        score.value += 4;
                        score.details.push('Clean HTML structure');
                        score.checks.push({ name: 'HTML5 structure', status: 'pass' });
                    } else if (semanticScore >= 2) {
                        score.value += 2;
                        score.checks.push({ name: 'HTML5 structure', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'HTML5 structure', status: 'fail' });
                    }
                    
                    // Check for alt text on images
                    const images = doc.querySelectorAll('img');
                    const imagesWithAlt = doc.querySelectorAll('img[alt]');
                    
                    if (images.length > 0 && imagesWithAlt.length / images.length > 0.8) {
                        score.value += 3;
                        score.details.push('Good alt text coverage');
                        score.checks.push({ name: 'Image alt text', status: 'pass' });
                    } else if (images.length > 0 && imagesWithAlt.length / images.length > 0.5) {
                        score.value += 1;
                        score.checks.push({ name: 'Image alt text', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Image alt text', status: 'fail' });
                    }
                    
                    // Check mobile viewport
                    const viewport = doc.querySelector('meta[name="viewport"]');
                    if (viewport) {
                        score.value += 3;
                        score.details.push('Mobile-optimized');
                        score.checks.push({ name: 'Mobile ready', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Mobile ready', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check technical signals');
            }
            
            return score;
        }

        async function checkContentFormat(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, 'text/html');
                    
                    // Check for FAQ sections
                    const hasFAQ = htmlContent.toLowerCase().includes('faq') || 
                                  htmlContent.includes('frequently asked') ||
                                  htmlContent.includes('"@type":"FAQPage"');
                    
                    if (hasFAQ) {
                        score.value += 3;
                        score.details.push('FAQ section found');
                        score.checks.push({ name: 'FAQ content', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'FAQ content', status: 'fail' });
                    }
                    
                    // Check for lists and tables
                    const lists = doc.querySelectorAll('ul, ol');
                    const tables = doc.querySelectorAll('table');
                    
                    if (lists.length > 2 || tables.length > 0) {
                        score.value += 3;
                        score.details.push('Structured content formats');
                        score.checks.push({ name: 'Lists/Tables', status: 'pass' });
                    } else if (lists.length > 0) {
                        score.value += 1;
                        score.checks.push({ name: 'Lists/Tables', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Lists/Tables', status: 'fail' });
                    }
                    
                    // Check for definitions or glossary
                    const hasDefinitions = doc.querySelector('dl') !== null ||
                                         htmlContent.includes('definition') ||
                                         htmlContent.includes('glossary');
                    
                    if (hasDefinitions) {
                        score.value += 2;
                        score.details.push('Definitions/glossary present');
                        score.checks.push({ name: 'Definitions', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Definitions', status: 'fail' });
                    }
                    
                    // Check content depth
                    const wordCount = doc.body ? doc.body.textContent.split(/\s+/).length : 0;
                    if (wordCount > 1000) {
                        score.value += 2;
                        score.details.push('Comprehensive content');
                        score.checks.push({ name: 'Content depth', status: 'pass' });
                    } else if (wordCount > 500) {
                        score.value += 1;
                        score.checks.push({ name: 'Content depth', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Content depth', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check content formats');
            }
            
            return score;
        }

        async function checkLicensing(baseUrl) {
            const score = { value: 0, max: 10, details: [], checks: [] };
            
            try {
                // Check robots.txt for differentiation
                const robotsUrl = `${baseUrl}/robots.txt`;
                const robotsContent = await fetchWithCORS(robotsUrl);
                
                if (robotsContent) {
                    // Check for training vs retrieval bot differentiation
                    const hasGPTBot = robotsContent.includes('GPTBot');
                    const hasSearchBot = robotsContent.includes('OAI-SearchBot') || robotsContent.includes('ChatGPT-User');
                    
                    if (hasGPTBot && hasSearchBot) {
                        score.value += 4;
                        score.details.push('Differentiates bot types');
                        score.checks.push({ name: 'Bot differentiation', status: 'pass' });
                    } else if (hasGPTBot || hasSearchBot) {
                        score.value += 2;
                        score.checks.push({ name: 'Bot differentiation', status: 'partial' });
                    } else {
                        score.checks.push({ name: 'Bot differentiation', status: 'fail' });
                    }
                    
                    // Check for llms.txt
                    if (robotsContent.includes('llms.txt')) {
                        score.value += 3;
                        score.details.push('llms.txt configured');
                        score.checks.push({ name: 'llms.txt policy', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'llms.txt policy', status: 'fail' });
                    }
                }
                
                // Check for terms/license page
                const htmlContent = await fetchWithCORS(baseUrl);
                if (htmlContent) {
                    const hasTerms = htmlContent.includes('terms') || 
                                   htmlContent.includes('license') ||
                                   htmlContent.includes('copyright');
                    
                    if (hasTerms) {
                        score.value += 3;
                        score.details.push('License/terms present');
                        score.checks.push({ name: 'Terms/License', status: 'pass' });
                    } else {
                        score.checks.push({ name: 'Terms/License', status: 'fail' });
                    }
                }
            } catch (error) {
                score.details.push('Unable to check licensing');
            }
            
            return score;
        }

        // [Display functions remain the same]
        function updateProgress(percent, message) {
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = percent + '%';
            progressBar.textContent = percent + '%';
            
            const loadingMessage = document.getElementById('loadingMessage');
            loadingMessage.textContent = message;
        }

        function calculateTotalScore() {
            let total = 0;
            for (const factor in analysisResults.factors) {
                total += analysisResults.factors[factor].value;
            }
            analysisResults.totalScore = Math.round(total);
        }

        function displayResults() {
            const resultsSection = document.getElementById('resultsSection');
            
            // Display total score with animation
            animateScore(analysisResults.totalScore);
            
            // Display factor cards
            displayFactors();
            
            // Generate recommendations
            generateRecommendations();
            
            // Show results
            resultsSection.classList.add('active');
        }

        function animateScore(targetScore) {
            const scoreElement = document.getElementById('totalScore');
            const scoreCircle = document.getElementById('scoreCircle');
            const scoreStatus = document.getElementById('scoreStatus');
            
            // Animate number
            let currentScore = 0;
            const increment = targetScore / 50;
            const timer = setInterval(() => {
                currentScore += increment;
                if (currentScore >= targetScore) {
                    currentScore = targetScore;
                    clearInterval(timer);
                }
                scoreElement.textContent = Math.round(currentScore);
            }, 20);
            
            // Animate circle (adjusted for max score of 80)
            const circumference = 2 * Math.PI * 90;
            const offset = circumference - (targetScore / 80) * circumference;
            scoreCircle.style.strokeDashoffset = offset;
            
            // Set status message
            if (targetScore >= 70) {
                scoreStatus.textContent = 'Excellent LLM Visibility';
                scoreStatus.style.color = '#4caf50';
            } else if (targetScore >= 50) {
                scoreStatus.textContent = 'Good LLM Visibility';
                scoreStatus.style.color = '#4caf50';
            } else if (targetScore >= 35) {
                scoreStatus.textContent = 'Moderate LLM Visibility';
                scoreStatus.style.color = '#ff9800';
            } else {
                scoreStatus.textContent = 'Needs Improvement';
                scoreStatus.style.color = '#f44336';
            }
        }

        function displayFactors() {
            const factorsGrid = document.getElementById('factorsGrid');
            factorsGrid.innerHTML = '';
            
            const factorNames = {
                botAccessibility: 'Bot Accessibility',
                parsability: 'Parsability & Structure',
                citationFriendliness: 'Citation Friendliness',
                authority: 'Authority & Trust',
                freshness: 'Freshness & Feeds',
                technical: 'Technical Signals',
                contentFormat: 'Content Format',
                licensing: 'Licensing Readiness'
            };
            
            for (const [key, factor] of Object.entries(analysisResults.factors)) {
                const card = createFactorCard(factorNames[key], factor);
                factorsGrid.appendChild(card);
            }
        }

        function createFactorCard(name, factor) {
            const card = document.createElement('div');
            card.className = 'factor-card';
            
            const scoreColor = factor.value >= 8 ? '#4caf50' : 
                             factor.value >= 5 ? '#ff9800' : '#f44336';
            
            card.innerHTML = `
                <div class="factor-header">
                    <div class="factor-title">${name}</div>
                    <div class="factor-score" style="color: ${scoreColor}">${factor.value}/${factor.max}</div>
                </div>
                <div class="factor-details">${factor.details.join(', ') || 'No details available'}</div>
                <ul class="factor-items">
                    ${factor.checks.map(check => `
                        <li>
                            <span class="check-icon ${check.status}">
                                ${check.status === 'pass' ? '✓' : check.status === 'partial' ? '~' : '✗'}
                            </span>
                            ${check.name}
                        </li>
                    `).join('')}
                </ul>
            `;
            
            return card;
        }

        function generateRecommendations() {
            const recommendations = document.getElementById('recommendations');
            const recs = [];
            
            // Analyze weak points and generate recommendations
            for (const [key, factor] of Object.entries(analysisResults.factors)) {
                if (factor.value < 6) {
                    recs.push(getRecommendation(key, factor));
                }
            }
            
            // Sort by priority (lowest scores first)
            recs.sort((a, b) => a.score - b.score);
            
            // Take top 3
            const topRecs = recs.slice(0, 3);
            
            recommendations.innerHTML = `
                <h2>📋 Top Recommendations</h2>
                ${topRecs.map((rec, index) => `
                    <div class="recommendation-item">
                        <span class="recommendation-priority">Priority ${index + 1}</span>
                        <div class="recommendation-title">${rec.title}</div>
                        <p>${rec.description}</p>
                        <ol class="recommendation-steps">
                            ${rec.steps.map(step => `<li>${step}</li>`).join('')}
                        </ol>
                    </div>
                `).join('')}
            `;
        }

        function getRecommendation(factorKey, factor) {
            const recommendations = {
                botAccessibility: {
                    title: 'Improve Bot Accessibility',
                    description: 'AI bots cannot properly access your site. This is critical for LLM visibility.',
                    steps: [
                        'Create or update robots.txt file in your root directory',
                        'Add these lines: User-agent: GPTBot\\nAllow: /',
                        'Add similar entries for ClaudeBot, OAI-SearchBot, and PerplexityBot',
                        'Create an llms.txt file listing your best content URLs',
                        'Test accessibility at robotstxt.com'
                    ]
                },
                parsability: {
                    title: 'Enhance Content Structure',
                    description: 'Your content structure needs improvement for AI understanding.',
                    steps: [
                        'Add clear H1 tags to all main pages (one per page)',
                        'Use H2 and H3 tags to create content hierarchy',
                        'Implement Schema.org markup using JSON-LD format',
                        'Add semantic HTML5 tags: <article>, <main>, <section>',
                        'Validate markup at schema.org/docs/validator'
                    ]
                },
                citationFriendliness: {
                    title: 'Make Content More Citable',
                    description: 'Your content is difficult for AI to quote and reference.',
                    steps: [
                        'Add author names to all content pieces',
                        'Include publication and update dates prominently',
                        'Break long content into 40-120 word paragraphs',
                        'Add internal links to related content',
                        'Include meta author and date tags in HTML head'
                    ]
                },
                authority: {
                    title: 'Build Trust Signals',
                    description: 'Your site lacks authority indicators that AI systems look for.',
                    steps: [
                        'Create comprehensive About and Contact pages',
                        'Add author bios with credentials to content',
                        'Display testimonials, reviews, or case studies',
                        'Ensure HTTPS is enabled site-wide',
                        'Add trust badges and certifications if applicable'
                    ]
                },
                freshness: {
                    title: 'Show Content Freshness',
                    description: 'AI cannot determine if your content is current.',
                    steps: [
                        'Create and submit XML sitemap with lastmod dates',
                        'Add RSS or Atom feed for new content',
                        'Display "Last Updated" dates on all pages',
                        'Update content regularly (at least monthly)',
                        'Include current year references in content'
                    ]
                },
                technical: {
                    title: 'Fix Technical Issues',
                    description: 'Technical problems make your site hard for AI to process.',
                    steps: [
                        'Add alt text to all images describing their content',
                        'Implement proper HTML5 semantic structure',
                        'Add viewport meta tag for mobile optimization',
                        'Use semantic tags: <header>, <main>, <article>, <footer>',
                        'Validate HTML at validator.w3.org'
                    ]
                },
                contentFormat: {
                    title: 'Add AI-Friendly Formats',
                    description: 'Your content formats are not optimized for AI extraction.',
                    steps: [
                        'Create FAQ sections with clear Q&A format',
                        'Add comparison tables and feature lists',
                        'Include definitions and glossaries for key terms',
                        'Use bullet points and numbered lists',
                        'Aim for 1000+ words on key topic pages'
                    ]
                },
                licensing: {
                    title: 'Prepare for AI Licensing',
                    description: 'Your site is not ready for AI content usage policies.',
                    steps: [
                        'Differentiate bot permissions in robots.txt',
                        'Create llms.txt with content guidelines',
                        'Add terms of service page addressing AI usage',
                        'Consider AI publisher programs (OpenAI, Perplexity)',
                        'Document your AI content policy clearly'
                    ]
                }
            };
            
            return {
                score: factor.value,
                ...recommendations[factorKey] || {
                    title: 'General Improvement',
                    description: 'This area needs attention.',
                    steps: ['Review best practices', 'Implement improvements', 'Test changes']
                }
            };
        }

        function showError(message) {
            document.getElementById('errorSection').style.display = 'block';
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('loadingSection').style.display = 'none';
        }

        // Allow Enter key to trigger analysis
        document.getElementById('domainInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                analyzeDomain();
            }
        });
        
        document.getElementById('domainAutoInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                analyzeAuto();
            }
        });
    </script>
</body>
</html>
